<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第五人格トラッカー | 戦績管理・勝率計算アプリ</title>
  <meta name="description" content="第五人格のランク戦戦績を簡単に記録・管理。勝率、キャラ別・マップ別・相手別の統計を自動計算。サバイバー/ハンター両対応。完全無料で使えるツール。">
  
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-EL23B3L2TD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-EL23B3L2TD');
  </script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      overflow: hidden;
    }
    
    .header {
      background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
      color: white;
      padding: 25px;
      text-align: center;
    }
    
    .header h1 {
      font-size: 32px;
      margin-bottom: 5px;
      font-weight: 700;
    }
    
    .header .subtitle {
      font-size: 14px;
      opacity: 0.9;
      font-weight: 400;
    }
    
    .perspective-tabs {
      display: flex;
      background: #f8f9fa;
      border-bottom: 2px solid #e0e0e0;
    }
    
    .perspective-tab {
      flex: 1;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      background: #f8f9fa;
      border: none;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s;
      color: #6b7280; /* 非アクティブは灰色 */
    }
    
    .perspective-tab.active {
      background: white;
      color: #3b82f6; /* アクティブは明るい青 */
      border-bottom: 3px solid #3b82f6;
    }
    
    .perspective-tab:hover {
      background: #e9ecef;
    }
    
    .main-tabs {
      display: flex;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      overflow-x: auto;
      position: relative; /* グラデーション用 */
    }
    
    /* スクロール可能であることを示すグラデーション（動的に表示/非表示） */
    .main-tabs.has-scroll::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 40px;
      background: linear-gradient(to right, 
        rgba(248, 249, 250, 0), 
        rgba(248, 249, 250, 1)
      );
      pointer-events: none;
      z-index: 1;
    }
    
    .main-tab {
      padding: 12px 20px;
      cursor: pointer;
      background: #f8f9fa;
      border: none;
      font-size: 14px;
      white-space: nowrap;
      transition: all 0.3s;
      color: #6b7280; /* 非アクティブは灰色 */
    }
    
    .main-tab.active {
      background: white;
      color: #3b82f6; /* アクティブは明るい青 */
      border-bottom: 2px solid #3b82f6;
    }
    
    .main-tab:hover {
      background: #e9ecef;
    }
    
    .content {
      padding: 25px;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    .form-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #333;
    }
    
    select {
      width: 100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      background: white;
      color: #3b82f6; /* 選択済みは明るい青（日付や脱出人数ボタンと同じ） */
    }
    
    /* 未選択状態（プレースホルダー）のスタイル */
    select.placeholder {
      color: #9ca3af; /* 薄いグレー */
    }
    
    select:focus {
      outline: none;
      border-color: #0f3460;
    }
    
    .result-buttons {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    
    .result-button {
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .result-button:hover {
      border-color: #0f3460;
      background: #e6f0ff;
    }
    
    .result-button.selected {
      background: #0f3460;
      color: white;
      border-color: #0f3460;
    }
    
    .submit-button {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #0f3460 0%, #533483 100%);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 20px;
      transition: transform 0.2s;
    }
    
    .submit-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(15, 52, 96, 0.4);
    }
    
    .submit-button:active {
      transform: translateY(0);
    }
    
    .filter-section {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .filter-group {
      flex: 1;
      min-width: 200px;
    }
    
    .filter-label {
      display: block;
      margin-bottom: 5px;
      font-size: 14px;
      font-weight: 600;
      color: #333;
    }
    
    .stats-card {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    
    .stats-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      color: #333;
    }
    
    .overall-stats-display {
      background: white;
      padding: 30px;
      border-radius: 8px;
      text-align: center;
    }
    
    .winrate-big {
      font-size: 48px;
      font-weight: 700;
      color: #0f3460;
      margin-bottom: 10px;
    }
    
    .record-text {
      font-size: 18px;
      color: #666;
      margin-bottom: 10px;
    }
    
    .streak-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 16px;
      font-weight: 600;
      margin-top: 10px;
    }
    
    .streak-icon {
      font-size: 20px;
    }
    
    /* 横棒グラフスタイル */
    .bar-chart-horizontal {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 20px;
      background: white;
      border-radius: 8px;
    }
    
    .bar-row {
      display: flex;
      align-items: center;
      gap: 12px;
      width: 100%;
      min-height: 45px;
    }
    
    .bar-label-wrapper {
      min-width: 110px;
      max-width: 110px;
      flex-shrink: 0;
    }
    
    .bar-label {
      font-size: 13px;
      font-weight: 600;
      color: #333;
      word-wrap: break-word;
      margin-bottom: 3px;
    }
    
    .bar-sublabel {
      font-size: 10px;
      color: #999;
      line-height: 1.3;
    }
    
    .bar-wrapper {
      flex: 1;
      min-width: 0;
      height: 28px;
      background: #f0f0f0;
      border-radius: 4px;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
    }
    
    .bar-visual {
      height: 100%;
      background: linear-gradient(90deg, #60a5fa, #3b82f6);
      border-radius: 4px;
      transition: width 0.3s ease;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 10px;
    }
    
    .bar-value {
      color: white;
      font-size: 11px;
      font-weight: 700;
      white-space: nowrap;
    }
    
    .bar-value-zero {
      position: static;
      transform: none;
      color: #999;
      background: transparent;
      font-size: 11px;
      font-weight: 600;
      padding-left: 10px;
    }
    
    .match-history {
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      overflow: hidden;
    }
    
    .match-item {
      padding: 15px;
      border-bottom: 1px solid #dee2e6;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .match-item:last-child {
      border-bottom: none;
    }
    
    .match-info {
      flex: 1;
    }
    
    .match-result {
      padding: 5px 12px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
      margin-right: 10px;
    }
    
    .match-result.win {
      background: #fef3c7;
      color: #92400e;
    }
    
    .match-result.lose {
      background: #f8d7da;
      color: #721c24;
    }
    
    .match-result.draw {
      background: #e5e7eb;
      color: #374151;
    }
    
    .match-actions button {
      margin-left: 5px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .edit-button {
      background: #ffc107;
      color: #000;
    }
    
    .delete-button {
      background: #dc3545;
      color: white;
    }
    
    .reset-button {
      background: #dc3545;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 20px;
    }
    
    .reset-button:hover {
      background: #c82333;
    }
    
    .empty-state {
      text-align: center;
      padding: 40px;
      color: #999;
    }
    
    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 10px;
    }
    
    /* レスポンシブ対応：スマホでは2列に */
    @media (max-width: 480px) {
      .teammate-grid,
      .opponent-survivor-grid {
        grid-template-columns: repeat(2, 1fr) !important;
      }
    }
    
    /* ===== 検索付きドロップダウン ===== */
    .searchable-select-wrapper {
      position: relative;
      width: 100%;
    }
    
    .searchable-select-wrapper select {
      display: none !important;
    }
    
    .ss-input {
      width: 100%;
      padding: 10px;
      padding-right: 32px;
      border: 2px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      background: white;
      color: #3b82f6;
      outline: none;
      cursor: text;
    }
    
    .ss-input::placeholder {
      color: #9ca3af;
    }
    
    .ss-input:focus {
      border-color: #0f3460;
    }
    
    .ss-input.has-value {
      color: #3b82f6;
    }
    
    .ss-clear {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      width: 22px;
      height: 22px;
      border: none;
      background: #e5e7eb;
      color: #6b7280;
      border-radius: 50%;
      font-size: 14px;
      line-height: 1;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }
    
    .ss-clear:hover {
      background: #d1d5db;
      color: #374151;
    }
    
    .ss-clear.visible {
      display: flex;
    }
    
    .ss-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 220px;
      overflow-y: auto;
      background: white;
      border: 2px solid #0f3460;
      border-top: none;
      border-radius: 0 0 6px 6px;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .ss-dropdown.open {
      display: block;
    }
    
    .ss-option {
      padding: 10px 12px;
      cursor: pointer;
      font-size: 14px;
      color: #333;
      border-bottom: 1px solid #f3f4f6;
      transition: background 0.1s;
    }
    
    .ss-option:last-child {
      border-bottom: none;
    }
    
    .ss-option:hover,
    .ss-option.highlighted {
      background: #e6f0ff;
      color: #0f3460;
    }
    
    .ss-no-result {
      padding: 12px;
      text-align: center;
      color: #9ca3af;
      font-size: 13px;
    }
    
    /* ===== 並び替えコントロール ===== */
    .sort-control {
      display: inline-flex;
      align-items: center;
      background: #f1f5f9;
      border-radius: 8px;
      padding: 3px;
      gap: 2px;
      margin-bottom: 15px;
    }
    .sort-key-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      background: transparent;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      color: #6b7280;
      transition: all 0.2s;
    }
    .sort-key-btn:hover { color: #374151; }
    .sort-key-btn.active {
      background: white;
      color: #0f3460;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    .sort-divider {
      width: 1px;
      height: 24px;
      background: #cbd5e1;
      margin: 0 2px;
    }
    .sort-arrow-btn {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 6px;
      background: transparent;
      font-size: 16px;
      font-weight: 800;
      cursor: pointer;
      color: #9ca3af;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .sort-arrow-btn:hover { color: #374151; }
    .sort-arrow-btn.active {
      background: white;
      color: #3b82f6;
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
    }
    
    /* ===== ダークモード切替スイッチ ===== */
    .dark-mode-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      background: #f8f9fa;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .dark-mode-toggle-label {
      font-size: 15px;
      font-weight: 600;
      color: #333;
    }
    .dark-mode-toggle-sub {
      font-size: 12px;
      color: #6b7280;
      margin-top: 2px;
    }
    .toggle-switch {
      position: relative;
      width: 52px;
      height: 28px;
      flex-shrink: 0;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: #cbd5e1;
      border-radius: 28px;
      transition: background 0.3s;
    }
    .toggle-slider::before {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      left: 3px;
      bottom: 3px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s;
    }
    .toggle-switch input:checked + .toggle-slider {
      background: #3b82f6;
    }
    .toggle-switch input:checked + .toggle-slider::before {
      transform: translateX(24px);
    }
    
    /* ===== ダークモード ===== */
    body.dark-mode {
      background: linear-gradient(135deg, #0d0d1a 0%, #0e1525 100%);
    }
    body.dark-mode .container {
      background: #1a1a2e;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    body.dark-mode .header {
      background: linear-gradient(135deg, #0a2240 0%, #0e1525 100%);
    }
    body.dark-mode .perspective-tabs {
      background: #222238;
      border-bottom-color: #2e2e48;
    }
    body.dark-mode .perspective-tab {
      background: #222238;
      color: #8888aa;
    }
    body.dark-mode .perspective-tab.active {
      background: #1a1a2e;
      color: #60a5fa;
      border-bottom-color: #60a5fa;
    }
    body.dark-mode .perspective-tab:hover {
      background: #2a2a42;
    }
    body.dark-mode .main-tabs {
      background: #222238;
      border-bottom-color: #2e2e48;
    }
    body.dark-mode .main-tabs.has-scroll::after {
      background: linear-gradient(to right, rgba(34,34,56,0), rgba(34,34,56,1));
    }
    body.dark-mode .main-tab {
      background: #222238;
      color: #8888aa;
    }
    body.dark-mode .main-tab.active {
      background: #1a1a2e;
      color: #60a5fa;
      border-bottom-color: #60a5fa;
    }
    body.dark-mode .main-tab:hover {
      background: #2a2a42;
    }
    body.dark-mode .content {
      background: #1a1a2e;
    }
    body.dark-mode .form-label {
      color: #d1d5db;
    }
    body.dark-mode select {
      background: #222238;
      border-color: #3a3a55;
      color: #60a5fa;
    }
    body.dark-mode select.placeholder {
      color: #6b7280;
    }
    body.dark-mode select:focus {
      border-color: #60a5fa;
    }
    body.dark-mode input[type="date"] {
      background: #222238 !important;
      border-color: #3a3a55 !important;
      color: #d1d5db !important;
    }
    body.dark-mode .result-button {
      background: #222238;
      border-color: #3a3a55;
      color: #d1d5db;
    }
    body.dark-mode .result-button:hover {
      border-color: #60a5fa;
      background: #1e2a45;
    }
    body.dark-mode .result-button.selected {
      background: #0f3460;
      color: white;
      border-color: #0f3460;
    }
    body.dark-mode .submit-button {
      background: linear-gradient(135deg, #1a4a8a 0%, #6d3fa0 100%);
    }
    body.dark-mode .filter-section {
      background: #222238;
    }
    body.dark-mode .filter-label {
      color: #d1d5db;
    }
    body.dark-mode .stats-card {
      background: #222238;
    }
    body.dark-mode .stats-title {
      color: #d1d5db;
    }
    body.dark-mode .overall-stats-display {
      background: #1e1e34;
    }
    body.dark-mode .winrate-big {
      color: #60a5fa;
    }
    body.dark-mode .record-text {
      color: #9ca3af;
    }
    body.dark-mode .bar-chart-horizontal {
      background: #1e1e34;
    }
    body.dark-mode .bar-label {
      color: #d1d5db;
    }
    body.dark-mode .bar-sublabel {
      color: #6b7280;
    }
    body.dark-mode .bar-wrapper {
      background: #2a2a42;
    }
    body.dark-mode .bar-value-zero {
      color: #6b7280;
    }
    body.dark-mode .match-history {
      background: #1e1e34;
      border-color: #2e2e48;
    }
    body.dark-mode .match-item {
      border-bottom-color: #2e2e48;
      color: #d1d5db;
    }
    body.dark-mode .match-info span {
      color: #d1d5db;
    }
    body.dark-mode .match-result.win {
      background: #3a2e0a;
      color: #fbbf24;
    }
    body.dark-mode .match-result.lose {
      background: #3a1e1e;
      color: #f87171;
    }
    body.dark-mode .match-result.draw {
      background: #2a2a3a;
      color: #a5a5c0;
    }
    body.dark-mode .edit-button {
      color: #60a5fa;
      border-color: #3a3a55;
    }
    body.dark-mode .delete-button {
      color: #f87171;
      border-color: #3a3a55;
    }
    body.dark-mode .empty-state {
      color: #6b7280;
    }
    body.dark-mode .reset-button {
      background: #991b1b;
    }
    body.dark-mode .reset-button:hover {
      background: #b91c1c;
    }
    /* ダークモード: ソートコントロール */
    body.dark-mode .sort-control {
      background: #2a2a42;
    }
    body.dark-mode .sort-key-btn {
      color: #8888aa;
    }
    body.dark-mode .sort-key-btn:hover {
      color: #d1d5db;
    }
    body.dark-mode .sort-key-btn.active {
      background: #1a1a2e;
      color: #60a5fa;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    body.dark-mode .sort-divider {
      background: #3a3a55;
    }
    body.dark-mode .sort-arrow-btn {
      color: #6b7280;
    }
    body.dark-mode .sort-arrow-btn:hover {
      color: #d1d5db;
    }
    body.dark-mode .sort-arrow-btn.active {
      background: #1a1a2e;
      color: #60a5fa;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    /* ダークモード: 検索ドロップダウン */
    body.dark-mode .ss-input {
      background: #222238;
      border-color: #3a3a55;
      color: #60a5fa;
    }
    body.dark-mode .ss-input::placeholder {
      color: #6b7280;
    }
    body.dark-mode .ss-input:focus {
      border-color: #60a5fa;
    }
    body.dark-mode .ss-clear {
      background: #3a3a55;
      color: #9ca3af;
    }
    body.dark-mode .ss-clear:hover {
      background: #4a4a65;
      color: #d1d5db;
    }
    body.dark-mode .ss-dropdown {
      background: #222238;
      border-color: #60a5fa;
    }
    body.dark-mode .ss-option {
      color: #d1d5db;
      border-bottom-color: #2e2e48;
    }
    body.dark-mode .ss-option:hover,
    body.dark-mode .ss-option.highlighted {
      background: #1e2a45;
      color: #60a5fa;
    }
    body.dark-mode .ss-no-result {
      color: #6b7280;
    }
    /* ダークモード: 設定タブ */
    body.dark-mode .dark-mode-toggle {
      background: #222238;
    }
    body.dark-mode .dark-mode-toggle-label {
      color: #d1d5db;
    }
    body.dark-mode .dark-mode-toggle-sub {
      color: #6b7280;
    }
    body.dark-mode h3, body.dark-mode h4 {
      color: #d1d5db !important;
    }
    body.dark-mode p {
      color: #9ca3af !important;
    }
    body.dark-mode textarea {
      background: #222238;
      border-color: #3a3a55;
      color: #d1d5db;
    }
    body.dark-mode #data-info {
      color: #d1d5db !important;
    }
    /* ===== 苦手カード ===== */
    .weakness-card {
      background: #f8f9fa;
      border-left: 3px solid #6c757d;
      padding: 12px 15px;
      margin-bottom: 15px;
      border-radius: 4px;
    }
    .weakness-title {
      font-weight: 600;
      font-size: 13px;
      color: #495057;
      margin-bottom: 8px;
    }
    .weakness-name {
      color: #212529;
    }
    .weakness-count {
      font-size: 11px;
      color: #6c757d;
      margin-left: 6px;
    }
    .weakness-rate {
      font-weight: 600;
      color: #6c757d;
    }
    .weakness-rate.weak {
      color: #dc3545;
    }
    /* ダークモード: 苦手キャラ警告 */
    body.dark-mode .weakness-card {
      background: #1e1e34;
      border-color: #f87171;
    }
    body.dark-mode .weakness-title {
      color: #d1d5db;
    }
    body.dark-mode .weakness-name {
      color: #d1d5db;
    }
    body.dark-mode .weakness-count {
      color: #8888aa;
    }
    body.dark-mode .weakness-rate {
      color: #8888aa;
    }
    body.dark-mode .weakness-rate.weak {
      color: #f87171;
    }
    /* ダークモード: ページネーション */
    body.dark-mode .pagination button {
      background: #222238;
      color: #d1d5db;
      border-color: #3a3a55;
    }
    body.dark-mode .pagination button:hover {
      background: #2a2a42;
    }
    body.dark-mode .pagination button.active {
      background: #0f3460;
      color: white;
    }
    /* ===== グラフコンテナ ===== */
    .chart-section-title {
      color: #374151;
    }
    .chart-container {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    body.dark-mode .chart-section-title {
      color: #d1d5db;
    }
    body.dark-mode .chart-container {
      background: #222238;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    /* ダークモード: チャート - JS側で色制御 */
    /* ダークモード: プライバシーリンク */
    body.dark-mode a[href="privacy.html"] {
      color: #6b7280 !important;
    }
    /* ダークモード: 保持ボタン・チェックボックスラベル */
    body.dark-mode span[style*="font-size: 12px"],
    body.dark-mode label[style*="font-size: 12px"] {
      color: #9ca3af;
    }
    body.dark-mode button[style*="background: #6c757d"] {
      background: #3a3a55 !important;
    }
  </style>
  
  <!-- Chart.js CDN (安定版v3) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>第五人格トラッカー</h1>
      <div class="subtitle">戦績管理・勝率計算</div>
    </div>
    
    <div class="perspective-tabs">
      <button class="perspective-tab active" onclick="switchPerspective('survivor')">サバイバー</button>
      <button class="perspective-tab" onclick="switchPerspective('hunter')">ハンター</button>
    </div>
    
    <div class="main-tabs">
      <button class="main-tab active" onclick="switchTab('input')">試合入力</button>
      <button class="main-tab" onclick="switchTab('overall')">総合勝率</button>
      <button class="main-tab" onclick="switchTab('character')">自キャラ別勝率</button>
      <button class="main-tab" onclick="switchTab('map')">マップ別勝率</button>
      <button class="main-tab" onclick="switchTab('opponent')">対戦相手別勝率</button>
      <button class="main-tab" onclick="switchTab('history')">試合履歴</button>
      <button class="main-tab" onclick="switchTab('settings')">設定</button>
    </div>
    
    <div class="content">
      <!-- 試合入力タブ -->
      <div id="input-tab" class="tab-content active">
        <div id="survivor-input">
          <button type="button" onclick="event.preventDefault(); event.stopPropagation(); clearAllPersistence('survivor'); return false;" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 6px; font-size: 13px; cursor: pointer; margin-bottom: 15px;">保持を全て解除</button>
          
          <div class="form-group">
            <label class="form-label">日付 <input type="checkbox" id="persist-survivor-date" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <input type="date" id="survivor-date" style="width: 100%; padding: 10px; border: 1px solid #cbd5e1; border-radius: 6px; font-size: 14px;">
          </div>
          
          <div class="form-group">
            <label class="form-label">段位 <input type="checkbox" id="persist-survivor-rank" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="survivor-rank">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">自分のサバイバー <input type="checkbox" id="persist-my-survivor" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="my-survivor" onchange="updateSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">味方サバイバー</label>
            <div class="teammate-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
              <div>
                <select id="teammate-1" onchange="updateSurvivorSelects()">
                  <option value="">選択してください</option>
                </select>
                <label style="display: block; margin-top: 5px; font-size: 12px;">
                  <input type="checkbox" id="persist-teammate-1" style="margin-right: 4px;">保持
                </label>
              </div>
              <div>
                <select id="teammate-2" onchange="updateSurvivorSelects()">
                  <option value="">選択してください</option>
                </select>
                <label style="display: block; margin-top: 5px; font-size: 12px;">
                  <input type="checkbox" id="persist-teammate-2" style="margin-right: 4px;">保持
                </label>
              </div>
              <div>
                <select id="teammate-3" onchange="updateSurvivorSelects()">
                  <option value="">選択してください</option>
                </select>
                <label style="display: block; margin-top: 5px; font-size: 12px;">
                  <input type="checkbox" id="persist-teammate-3" style="margin-right: 4px;">保持
                </label>
              </div>
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label">相手ハンター <input type="checkbox" id="persist-opponent-hunter" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="opponent-hunter">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">マップ <input type="checkbox" id="persist-survivor-map" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="survivor-map">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">脱出人数</label>
            <div class="result-buttons">
              <button class="result-button" onclick="selectEscapeCount('survivor', 0)">0人</button>
              <button class="result-button" onclick="selectEscapeCount('survivor', 1)">1人</button>
              <button class="result-button" onclick="selectEscapeCount('survivor', 2)">2人</button>
              <button class="result-button" onclick="selectEscapeCount('survivor', 3)">3人</button>
              <button class="result-button" onclick="selectEscapeCount('survivor', 4)">4人</button>
            </div>
          </div>
          
          <button type="button" class="submit-button" onclick="submitMatch('survivor')">試合を記録</button>
        </div>
        
        <div id="hunter-input" style="display: none;">
          <button type="button" onclick="event.preventDefault(); event.stopPropagation(); clearAllPersistence('hunter'); return false;" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 6px; font-size: 13px; cursor: pointer; margin-bottom: 15px;">保持を全て解除</button>
          
          <div class="form-group">
            <label class="form-label">日付 <input type="checkbox" id="persist-hunter-date" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <input type="date" id="hunter-date" style="width: 100%; padding: 10px; border: 1px solid #cbd5e1; border-radius: 6px; font-size: 14px;">
          </div>
          
          <div class="form-group">
            <label class="form-label">段位 <input type="checkbox" id="persist-hunter-rank" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="hunter-rank">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">自分のハンター <input type="checkbox" id="persist-my-hunter" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="my-hunter">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">相手サバイバー</label>
            <div class="opponent-survivor-grid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
              <div>
                <select id="opponent-survivor-1" onchange="updateOpponentSurvivorSelects()">
                  <option value="">選択してください</option>
                </select>
                <label style="display: block; margin-top: 5px; font-size: 12px;">
                  <input type="checkbox" id="persist-opponent-survivor-1" style="margin-right: 4px;">保持
                </label>
              </div>
              <div>
                <select id="opponent-survivor-2" onchange="updateOpponentSurvivorSelects()">
                  <option value="">選択してください</option>
                </select>
                <label style="display: block; margin-top: 5px; font-size: 12px;">
                  <input type="checkbox" id="persist-opponent-survivor-2" style="margin-right: 4px;">保持
                </label>
              </div>
              <div>
                <select id="opponent-survivor-3" onchange="updateOpponentSurvivorSelects()">
                  <option value="">選択してください</option>
                </select>
                <label style="display: block; margin-top: 5px; font-size: 12px;">
                  <input type="checkbox" id="persist-opponent-survivor-3" style="margin-right: 4px;">保持
                </label>
              </div>
              <div>
                <select id="opponent-survivor-4" onchange="updateOpponentSurvivorSelects()">
                  <option value="">選択してください</option>
                </select>
                <label style="display: block; margin-top: 5px; font-size: 12px;">
                  <input type="checkbox" id="persist-opponent-survivor-4" style="margin-right: 4px;">保持
                </label>
              </div>
            </div>
          </div>
          
          <div class="form-group">
            <label class="form-label">マップ <input type="checkbox" id="persist-hunter-map" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="hunter-map">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">脱出人数</label>
            <div class="result-buttons">
              <button class="result-button" onclick="selectEscapeCount('hunter', 0)">0人</button>
              <button class="result-button" onclick="selectEscapeCount('hunter', 1)">1人</button>
              <button class="result-button" onclick="selectEscapeCount('hunter', 2)">2人</button>
              <button class="result-button" onclick="selectEscapeCount('hunter', 3)">3人</button>
              <button class="result-button" onclick="selectEscapeCount('hunter', 4)">4人</button>
            </div>
          </div>
          
          <button class="submit-button" onclick="submitMatch('hunter')">試合を記録</button>
        </div>
      </div>
      
      <!-- 総合勝率タブ -->
      <div id="overall-tab" class="tab-content">
        <!-- 期間フィルター -->
        <div style="margin-bottom: 20px;">
          <label style="font-size: 13px; color: #374151; margin-bottom: 5px; display: block; font-weight: 600;">期間フィルター</label>
          <select id="overall-period-filter" onchange="updateOverallStatsTab()" style="width: 100%; padding: 10px; border: 1px solid #cbd5e1; border-radius: 6px; font-size: 14px;">
            <option value="all">全期間</option>
            <option value="recent100">百戦勝率</option>
          </select>
        </div>
        
        <!-- 総合勝率表示 -->
        <div id="overall-stats-display"></div>
        
        <!-- 直近10試合の勝率推移グラフ -->
        <div style="margin-top: 30px;">
          <h3 class="chart-section-title" style="font-size: 16px; font-weight: 600; margin-bottom: 15px;">直近10試合の勝率推移</h3>
          <div class="chart-container">
            <canvas id="winrate-chart" style="max-height: 300px;"></canvas>
          </div>
        </div>
      </div>
      
      <!-- 自キャラ別勝率タブ -->
      <div id="character-tab" class="tab-content">
        <div class="filter-section">
          <div class="filter-group">
            <label class="filter-label">期間フィルター</label>
            <select id="character-period-filter" onchange="updateAllStats()">
              <option value="all">全期間</option>
              <option value="today">今日</option>
              <option value="last7days">直近7日</option>
              <option value="last30days">直近30日</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">段位フィルター</label>
            <select id="character-rank-filter" onchange="updateAllStats()">
              <option value="all">全段位</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">マップフィルター</label>
            <select id="character-map-filter" onchange="updateAllStats()">
              <option value="all">全マップ</option>
            </select>
          </div>
        </div>
        <div id="character-stats"></div>
      </div>
      
      <!-- マップ別勝率タブ -->
      <div id="map-tab" class="tab-content">
        <div class="filter-section">
          <div class="filter-group">
            <label class="filter-label">期間フィルター</label>
            <select id="map-period-filter" onchange="updateAllStats()">
              <option value="all">全期間</option>
              <option value="today">今日</option>
              <option value="last7days">直近7日</option>
              <option value="last30days">直近30日</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">段位フィルター</label>
            <select id="map-rank-filter" onchange="updateAllStats()">
              <option value="all">全段位</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">自キャラフィルター</label>
            <select id="map-char-filter" onchange="updateAllStats()">
              <option value="all">全キャラ</option>
            </select>
          </div>
        </div>
        <div id="map-stats"></div>
      </div>
      
      <!-- 対戦相手別勝率タブ -->
      <div id="opponent-tab" class="tab-content">
        <div class="filter-section">
          <div class="filter-group">
            <label class="filter-label">期間フィルター</label>
            <select id="opponent-period-filter" onchange="updateAllStats()">
              <option value="all">全期間</option>
              <option value="today">今日</option>
              <option value="last7days">直近7日</option>
              <option value="last30days">直近30日</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">段位フィルター</label>
            <select id="opponent-rank-filter" onchange="updateAllStats()">
              <option value="all">全段位</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">自キャラフィルター</label>
            <select id="my-char-filter" onchange="onMyCharFilterChange()">
              <option value="all">全キャラ</option>
            </select>
          </div>
          <div class="filter-group" id="opponent-filter-group">
            <label class="filter-label">対戦相手フィルター</label>
            <select id="opponent-hunter-filter" onchange="updateAllStats()">
              <option value="all">全て</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">マップフィルター</label>
            <select id="opponent-map-filter" onchange="updateAllStats()">
              <option value="all">全マップ</option>
            </select>
          </div>
        </div>
        <div id="opponent-stats"></div>
      </div>
      
      <!-- 試合履歴タブ -->
      <div id="history-tab" class="tab-content">
        <div class="filter-section">
          <div class="filter-group">
            <label class="filter-label">期間フィルター</label>
            <select id="history-period-filter" onchange="updateAllStats()">
              <option value="all">全期間</option>
              <option value="today">今日</option>
              <option value="last7days">直近7日</option>
              <option value="last30days">直近30日</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">段位フィルター</label>
            <select id="history-rank-filter" onchange="updateAllStats()">
              <option value="all">全段位</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">相手キャラフィルター</label>
            <select id="history-opponent-filter" onchange="updateAllStats()">
              <option value="all">全キャラ</option>
            </select>
          </div>
        </div>
        <div id="match-history"></div>
        <button type="button" class="reset-button" onclick="event.stopPropagation(); resetAllData(); return false;">全データをリセット</button>
      </div>
      
      <!-- 設定タブ -->
      <div id="settings-tab" class="tab-content">
        <!-- ダークモード切替 -->
        <div class="dark-mode-toggle">
          <div>
            <div class="dark-mode-toggle-label">ダークモード</div>
            <div class="dark-mode-toggle-sub">目に優しい暗い配色に切り替えます</div>
          </div>
          <label class="toggle-switch">
            <input type="checkbox" id="dark-mode-switch" onchange="toggleDarkMode()">
            <span class="toggle-slider"></span>
          </label>
        </div>
        
        <div class="stats-card" style="margin-bottom: 20px;">
          <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 15px; color: #1f2937;">データのバックアップと復元</h3>
          <p style="font-size: 13px; color: #6b7280; margin-bottom: 20px; line-height: 1.6;">
            試合データをバックアップして、機種変更時やブラウザのデータ削除に備えることができます。<br>
            スマホで入力したデータをPCで分析したり、複数のデバイス間でデータを共有することも可能です。
          </p>
          
          <!-- エクスポート -->
          <div style="margin-bottom: 30px;">
            <h4 style="font-size: 14px; font-weight: 600; margin-bottom: 10px; color: #374151;">データをバックアップ</h4>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
              <button type="button" onclick="exportToClipboard()" style="flex: 1; min-width: 200px; padding: 12px 20px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;">
                クリップボードにコピー
              </button>
              <button type="button" onclick="exportToFile()" style="flex: 1; min-width: 200px; padding: 12px 20px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;">
                ファイルでダウンロード
              </button>
            </div>
            <p style="font-size: 12px; color: #6b7280; margin-top: 8px;">
              クリップボードにコピーした場合は、LINEやメモ帳に貼り付けて保存してください。
            </p>
          </div>
          
          <!-- インポート -->
          <div>
            <h4 style="font-size: 14px; font-weight: 600; margin-bottom: 10px; color: #374151;">データを復元</h4>
            <p style="font-size: 12px; color: #dc2626; margin-bottom: 10px; font-weight: 600;">
              復元すると現在のデータは完全に上書きされます
            </p>
            
            <!-- テキストエリアで復元 -->
            <div style="margin-bottom: 15px;">
              <label style="font-size: 13px; color: #374151; margin-bottom: 5px; display: block;">バックアップデータを貼り付け:</label>
              <textarea id="import-textarea" placeholder="ここにバックアップデータを貼り付けてください" style="width: 100%; height: 120px; padding: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; font-family: monospace; resize: vertical;"></textarea>
              <button type="button" onclick="importFromText()" style="width: 100%; padding: 12px 20px; background: #8b5cf6; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; margin-top: 10px;">
                テキストから復元
              </button>
            </div>
            
            <!-- ファイルで復元 -->
            <div>
              <label style="font-size: 13px; color: #374151; margin-bottom: 5px; display: block;">またはファイルから復元:</label>
              <input type="file" id="import-file" accept=".json,.txt" style="display: none;" onchange="importFromFile(event)">
              <button type="button" onclick="document.getElementById('import-file').click()" style="width: 100%; padding: 12px 20px; background: #6366f1; color: white; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;">
                ファイルから復元
              </button>
            </div>
          </div>
        </div>
        
        <!-- 現在のデータ情報 -->
        <div class="stats-card">
          <h3 style="font-size: 16px; font-weight: 600; margin-bottom: 15px; color: #1f2937;">現在のデータ情報</h3>
          <div id="data-info" style="font-size: 13px; color: #374151; line-height: 1.8;"></div>
        </div>
      </div>
    </div>
    
    <!-- プライバシーポリシーリンク -->
    <div style="text-align: center; padding: 30px 20px 20px 20px;">
      <a href="privacy.html" style="color: #94a3b8; text-decoration: none; font-size: 13px; transition: color 0.2s;" onmouseover="this.style.color='#cbd5e1'" onmouseout="this.style.color='#94a3b8'">プライバシーポリシー</a>
    </div>
  </div>

  <script>
    const SURVIVORS = ['幸運児', '医師', '弁護士', '泥棒', '庭師', 'マジシャン', '冒険家', '傭兵', '祭司', '空軍', '機械技師', 'オフェンス', '心眼', '調香師', 'カウボーイ', '踊り子', '占い師', '納棺師', '探鉱者', '呪術師', '野人', '曲芸師', '一等航海士', 'バーメイド', 'ポストマン', '墓守', '「囚人」', '昆虫学者', '画家', 'バッツマン', '玩具職人', '患者', '「心理学者」', '小説家', '「少女」', '泣きピエロ', '教授', '骨董商', '作曲家', '記者', '航空エンジニア', '応援団', '人形師', '火災調査員', '「レディ・ファウロ」', '「騎士」', '気象学者', '弓使い', '「脱出マスター」', '幻灯師', '闘牛士'];
    
    const HUNTERS = ['復讐者', '道化師', '断罪狩人', 'リッパー', '結魂者', '芸者', '白黒無常', '写真家', '狂眼', '黄衣の王', '夢の魔女', '泣き虫', '魔トカゲ', '血の女王', 'ガードNo.26', '「使徒」', 'ヴァイオリニスト', '彫刻師', 'アンデッド', '破輪', '漁師', '蝋人形師', '「悪夢」', '書記官', '隠者', '夜の番人', 'オペラ歌手', '「フールズ・ゴールド」', '時空の影', '「足萎えの羊」', '「フラバルー」', '雑貨商', '「ビリヤードプレイヤー」', '「女王蜂」'];
    
    const MAPS = ['軍需工場', '赤の教会', '聖心病院', '湖景村', '月の河公園', 'レオの思い出', '永眠町', '中華街', '罪の森'];
    
    const RANKS = ['1段', '2段', '3段', '4段', '5段', '6段', '7段', '最高峰'];
    
    // ===== ひらがな読みデータ =====
    const SURVIVOR_READINGS = {
      '幸運児': 'こううんじ',
      '医師': 'いし',
      '弁護士': 'べんごし',
      '泥棒': 'どろぼう',
      '庭師': 'にわし',
      'マジシャン': 'まじしゃん',
      '冒険家': 'ぼうけんか',
      '傭兵': 'ようへい',
      '祭司': 'さいし',
      '空軍': 'くうぐん',
      '機械技師': 'きかいぎし',
      'オフェンス': 'おふぇんす',
      '心眼': 'しんがん',
      '調香師': 'ちょうこうし',
      'カウボーイ': 'かうぼーい',
      '踊り子': 'おどりこ',
      '占い師': 'うらないし',
      '納棺師': 'のうかんし',
      '探鉱者': 'たんこうしゃ',
      '呪術師': 'じゅじゅつし',
      '野人': 'やじん',
      '曲芸師': 'きょくげいし',
      '一等航海士': 'いっとうこうかいし',
      'バーメイド': 'ばーめいど',
      'ポストマン': 'ぽすとまん',
      '墓守': 'はかもり',
      '「囚人」': 'しゅうじん',
      '昆虫学者': 'こんちゅうがくしゃ',
      '画家': 'がか',
      'バッツマン': 'ばっつまん',
      '玩具職人': 'おもちゃしょくにん',
      '患者': 'かんじゃ',
      '「心理学者」': 'しんりがくしゃ',
      '小説家': 'しょうせつか',
      '「少女」': 'しょうじょ',
      '泣きピエロ': 'なきぴえろ',
      '教授': 'きょうじゅ',
      '骨董商': 'こっとうしょう',
      '作曲家': 'さっきょくか',
      '記者': 'きしゃ',
      '航空エンジニア': 'こうくうえんじにあ',
      '応援団': 'おうえんだん',
      '人形師': 'にんぎょうし',
      '火災調査員': 'かさいちょうさいん',
      '「レディ・ファウロ」': 'れでぃふぁうろ',
      '「騎士」': 'きし',
      '気象学者': 'きしょうがくしゃ',
      '弓使い': 'ゆみつかい',
      '「脱出マスター」': 'だっしゅつますたー',
      '幻灯師': 'げんとうし',
      '闘牛士': 'とうぎゅうし'
    };
    
    const HUNTER_READINGS = {
      '復讐者': 'ふくしゅうしゃ れお',
      '道化師': 'どうけし ぴえろ',
      '断罪狩人': 'だんざいかりゅうど しか',
      'リッパー': 'りっぱー',
      '結魂者': 'けっこんしゃ くも',
      '芸者': 'げいしゃ みちこ',
      '白黒無常': 'しろくろむじょう',
      '写真家': 'しゃしんか じょぜふ',
      '狂眼': 'きょうがん ばるく',
      '黄衣の王': 'おういのおう たこ',
      '夢の魔女': 'ゆめのまじょ',
      '泣き虫': 'なきむし',
      '魔トカゲ': 'まとかげ るきの',
      '血の女王': 'ちのじょおう まりー',
      'ガードNo.26': 'がーどにじゅうろく ぼんぼん',
      '「使徒」': 'しと あん',
      'ヴァイオリニスト': 'ゔぁいおりにすと あんとにお',
      '彫刻師': 'ちょうこくし がらてあ',
      'アンデッド': 'あんでっど',
      '破輪': 'はりん うぃる',
      '漁師': 'りょうし ぐれいす',
      '蝋人形師': 'ろうにんぎょうし',
      '「悪夢」': 'あくむ',
      '書記官': 'しょきかん きーがん',
      '隠者': 'いんじゃ',
      '夜の番人': 'よるのばんにん いたか',
      'オペラ歌手': 'おぺらかしゅ さんぐりあ',
      '「フールズ・ゴールド」': 'ふーるずごーるど',
      '時空の影': 'じくうのかげ あいゔぃ',
      '「足萎えの羊」': 'あしなえのひつじ',
      '「フラバルー」': 'ふらばるー',
      '雑貨商': 'ざっかしょう',
      '「ビリヤードプレイヤー」': 'びりやーどぷれいやー',
      '「女王蜂」': 'じょおうばち'
    };
    
    // カタカナ→ひらがな変換
    function katakanaToHiragana(str) {
      return str.replace(/[\u30A1-\u30F6]/g, ch =>
        String.fromCharCode(ch.charCodeAt(0) - 0x60)
      );
    }
    
    // ===== 検索付きドロップダウン =====
    class SearchableSelect {
      constructor(selectEl) {
        this.select = selectEl;
        this.value = selectEl.value;
        this.highlightIndex = -1;
        this.isOpen = false;
        this.options = []; // {value, label, reading}
        
        this._build();
        this._bindEvents();
      }
      
      _build() {
        // ラッパー
        this.wrapper = document.createElement('div');
        this.wrapper.className = 'searchable-select-wrapper';
        this.select.parentNode.insertBefore(this.wrapper, this.select);
        this.wrapper.appendChild(this.select);
        
        // テキスト入力
        this.input = document.createElement('input');
        this.input.type = 'text';
        this.input.className = 'ss-input';
        this.input.placeholder = '検索して選択...';
        this.input.autocomplete = 'off';
        this.wrapper.insertBefore(this.input, this.select);
        
        // クリアボタン
        this.clearBtn = document.createElement('button');
        this.clearBtn.type = 'button';
        this.clearBtn.className = 'ss-clear';
        this.clearBtn.innerHTML = '×';
        this.clearBtn.tabIndex = -1;
        this.wrapper.insertBefore(this.clearBtn, this.select);
        
        // ドロップダウン
        this.dropdown = document.createElement('div');
        this.dropdown.className = 'ss-dropdown';
        this.wrapper.appendChild(this.dropdown);
        
        // 初期値を反映
        if (this.select.value) {
          this.input.value = this.select.value;
          this.input.classList.add('has-value');
          this.clearBtn.classList.add('visible');
        }
      }
      
      _bindEvents() {
        // フォーカス時にドロップダウンを開く
        this.input.addEventListener('focus', () => {
          this._refreshOptions();
          this._filterAndRender('');
          this._open();
          this.input.select();
        });
        
        // 入力時にフィルター
        this.input.addEventListener('input', () => {
          this._filterAndRender(this.input.value);
          if (!this.isOpen) this._open();
        });
        
        // キーボード操作
        this.input.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowDown') {
            e.preventDefault();
            this._moveHighlight(1);
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            this._moveHighlight(-1);
          } else if (e.key === 'Enter') {
            e.preventDefault();
            this._selectHighlighted();
          } else if (e.key === 'Escape') {
            this._close();
            this.input.blur();
          }
        });
        
        // クリアボタン
        this.clearBtn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.setValue('');
          this.input.focus();
        });
        
        // 外側クリックで閉じる
        document.addEventListener('click', (e) => {
          if (!this.wrapper.contains(e.target)) {
            this._close();
            // 未確定なら元に戻す
            if (this.value) {
              this.input.value = this.value;
            } else {
              this.input.value = '';
            }
          }
        });
      }
      
      _refreshOptions() {
        this.options = [];
        const opts = this.select.querySelectorAll('option');
        opts.forEach(opt => {
          if (opt.value === '') return; // placeholder skip
          const label = opt.textContent;
          const isSurvivor = SURVIVORS.includes(label);
          const reading = isSurvivor ? (SURVIVOR_READINGS[label] || '') : (HUNTER_READINGS[label] || '');
          this.options.push({ value: opt.value, label, reading });
        });
      }
      
      _filterAndRender(query) {
        const q = katakanaToHiragana(query.toLowerCase().trim());
        this.dropdown.innerHTML = '';
        this.highlightIndex = -1;
        
        let filtered;
        if (!q) {
          filtered = this.options;
        } else {
          filtered = this.options.filter(opt => {
            const label = opt.label.toLowerCase();
            const reading = opt.reading;
            return label.includes(q) || reading.includes(q);
          });
        }
        
        if (filtered.length === 0) {
          const noResult = document.createElement('div');
          noResult.className = 'ss-no-result';
          noResult.textContent = '該当なし';
          this.dropdown.appendChild(noResult);
          this._filteredOptions = [];
          return;
        }
        
        this._filteredOptions = filtered;
        
        filtered.forEach((opt, idx) => {
          const div = document.createElement('div');
          div.className = 'ss-option';
          div.dataset.index = idx;
          
          let html = opt.label;
          div.innerHTML = html;
          
          div.addEventListener('mousedown', (e) => {
            e.preventDefault(); // prevent blur
          });
          div.addEventListener('click', (e) => {
            e.stopPropagation();
            this._selectOption(opt);
          });
          
          this.dropdown.appendChild(div);
        });
      }
      
      _open() {
        this.isOpen = true;
        this.dropdown.classList.add('open');
        this.input.style.borderRadius = '6px 6px 0 0';
      }
      
      _close() {
        this.isOpen = false;
        this.dropdown.classList.remove('open');
        this.input.style.borderRadius = '6px';
        this.highlightIndex = -1;
      }
      
      _moveHighlight(dir) {
        if (!this._filteredOptions || this._filteredOptions.length === 0) return;
        const items = this.dropdown.querySelectorAll('.ss-option');
        if (items.length === 0) return;
        
        // 前のハイライトを除去
        if (this.highlightIndex >= 0 && this.highlightIndex < items.length) {
          items[this.highlightIndex].classList.remove('highlighted');
        }
        
        this.highlightIndex += dir;
        if (this.highlightIndex < 0) this.highlightIndex = items.length - 1;
        if (this.highlightIndex >= items.length) this.highlightIndex = 0;
        
        items[this.highlightIndex].classList.add('highlighted');
        items[this.highlightIndex].scrollIntoView({ block: 'nearest' });
      }
      
      _selectHighlighted() {
        if (this.highlightIndex >= 0 && this._filteredOptions && this.highlightIndex < this._filteredOptions.length) {
          this._selectOption(this._filteredOptions[this.highlightIndex]);
        }
      }
      
      _selectOption(opt) {
        this.setValue(opt.value);
        this._close();
        this.input.blur();
        
        // 既存のchangeイベントを発火
        this.select.dispatchEvent(new Event('change', { bubbles: true }));
      }
      
      // 外部から値を設定
      setValue(val) {
        this.value = val;
        this.select.value = val;
        
        if (val) {
          this.input.value = val;
          this.input.classList.add('has-value');
          this.clearBtn.classList.add('visible');
        } else {
          this.input.value = '';
          this.input.classList.remove('has-value');
          this.clearBtn.classList.remove('visible');
        }
        updatePlaceholderStyle(this.select);
      }
      
      // selectの値と同期（外部でselectが変更された場合）
      syncFromSelect() {
        const val = this.select.value;
        this.value = val;
        if (val) {
          this.input.value = val;
          this.input.classList.add('has-value');
          this.clearBtn.classList.add('visible');
        } else {
          this.input.value = '';
          this.input.classList.remove('has-value');
          this.clearBtn.classList.remove('visible');
        }
      }
    }
    
    // SearchableSelectインスタンスを管理
    const searchableSelects = {};
    
    // selectをSearchableSelectに変換
    function initSearchableSelect(selectId) {
      const selectEl = document.getElementById(selectId);
      if (!selectEl || searchableSelects[selectId]) return;
      searchableSelects[selectId] = new SearchableSelect(selectEl);
    }
    
    // 全キャラ選択selectをSearchableSelectに変換
    function initAllSearchableSelects() {
      const charSelectIds = [
        'my-survivor', 'teammate-1', 'teammate-2', 'teammate-3',
        'opponent-hunter',
        'my-hunter',
        'opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'
      ];
      charSelectIds.forEach(id => initSearchableSelect(id));
    }
    
    // SearchableSelectの値同期用ヘルパー
    function syncSearchableSelect(selectId) {
      if (searchableSelects[selectId]) {
        searchableSelects[selectId].syncFromSelect();
      }
    }
    
    function setSearchableSelectValue(selectId, value) {
      const ss = searchableSelects[selectId];
      if (ss) {
        ss.setValue(value);
      } else {
        const el = document.getElementById(selectId);
        if (el) el.value = value;
      }
    }
    
    const SEASONS = [
      { id: 'S41', label: 'S41', start: '2026-02-05', end: '2026-04-22' }
      // 新しいシーズンはここに追加
      // { id: 'S42', label: 'S42', start: '2026-04-23', end: '2026-07-15' }
    ];
    
    // 期間フィルターにシーズンを追加
    function populatePeriodFilters() {
      // 総合勝率タブの期間フィルター（全期間、百戦勝率、シーズン）
      const overallFilter = document.getElementById('overall-period-filter');
      if (overallFilter) {
        const sortedSeasons = [...SEASONS].reverse();
        sortedSeasons.forEach(season => {
          const option = document.createElement('option');
          option.value = season.id;
          option.textContent = season.label;
          overallFilter.appendChild(option);
        });
      }
      
      // 他のタブの期間フィルター（全期間、今日、直近7日、直近30日、シーズン）
      const filterIds = ['character-period-filter', 'map-period-filter', 'opponent-period-filter', 'history-period-filter'];
      
      filterIds.forEach(filterId => {
        const filter = document.getElementById(filterId);
        if (!filter) return;
        
        // シーズンを新しい順に追加
        const sortedSeasons = [...SEASONS].reverse();
        sortedSeasons.forEach(season => {
          const option = document.createElement('option');
          option.value = season.id;
          option.textContent = season.label;
          filter.appendChild(option);
        });
      });
    }
    
    // 日付を YYYY-MM-DD 形式に変換
    function formatDate(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }
    
    // プレースホルダースタイルを更新
    function updatePlaceholderStyle(select) {
      if (!select) return;
      if (select.value === '' || select.value === null) {
        select.classList.add('placeholder');
      } else {
        select.classList.remove('placeholder');
      }
    }
    
    // 全てのselectにプレースホルダースタイルを初期化
    function initializePlaceholderStyles() {
      const allSelects = document.querySelectorAll('select');
      allSelects.forEach(select => {
        // 初期状態を設定
        updatePlaceholderStyle(select);
        
        // changeイベントを追加
        select.addEventListener('change', function() {
          updatePlaceholderStyle(this);
        });
      });
    }
    
    // タブのスクロール監視を初期化
    function initializeTabScrollIndicator() {
      const tabs = document.querySelector('.main-tabs');
      if (!tabs) return;
      
      function updateScrollIndicator() {
        const isScrollable = tabs.scrollWidth > tabs.clientWidth;
        const isAtEnd = tabs.scrollLeft + tabs.clientWidth >= tabs.scrollWidth - 5;
        
        if (isScrollable && !isAtEnd) {
          tabs.classList.add('has-scroll');
        } else {
          tabs.classList.remove('has-scroll');
        }
      }
      
      // 初期状態を設定
      updateScrollIndicator();
      
      // スクロールイベントを監視
      tabs.addEventListener('scroll', updateScrollIndicator);
      
      // リサイズイベントを監視
      window.addEventListener('resize', updateScrollIndicator);
    }
    
    // 今日の日付を取得
    function getToday() {
      return formatDate(new Date());
    }
    
    // 日付入力フィールドの初期値を設定
    function initializeDateFields() {
      const today = getToday();
      
      // サバイバー
      const survivorDate = document.getElementById('survivor-date');
      if (survivorDate && !survivorDate.value) {
        survivorDate.value = today;
      }
      
      // ハンター
      const hunterDate = document.getElementById('hunter-date');
      if (hunterDate && !hunterDate.value) {
        hunterDate.value = today;
      }
    }
    
    // 期間フィルターで試合をフィルタリング
    function filterByPeriod(matches, periodValue) {
      if (periodValue === 'all') {
        return matches;
      }
      
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      if (periodValue === 'today') {
        const todayStr = formatDate(today);
        return matches.filter(m => m.date === todayStr);
      }
      
      if (periodValue === 'last7days') {
        const sevenDaysAgo = new Date(today);
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 6); // 今日を含む7日間
        return matches.filter(m => {
          if (!m.date) return false;
          const matchDate = new Date(m.date);
          matchDate.setHours(0, 0, 0, 0);
          return matchDate >= sevenDaysAgo && matchDate <= today;
        });
      }
      
      if (periodValue === 'last30days') {
        const thirtyDaysAgo = new Date(today);
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 29); // 今日を含む30日間
        return matches.filter(m => {
          if (!m.date) return false;
          const matchDate = new Date(m.date);
          matchDate.setHours(0, 0, 0, 0);
          return matchDate >= thirtyDaysAgo && matchDate <= today;
        });
      }
      
      // シーズンでフィルター
      const season = SEASONS.find(s => s.id === periodValue);
      if (season) {
        return matches.filter(m => {
          if (!m.date) return false;
          return m.date >= season.start && m.date <= season.end;
        });
      }
      
      return matches;
    }
    
    let currentPerspective = 'survivor';
    let selectedEscapeCount = { survivor: null, hunter: null };
    let matches = [];
    let editingMatchId = null;
    
    // キャラクター使用回数を記録（サバイバー/ハンター別）
    let characterUsageCount = {
      survivorUsed: {},   // サバイバーとして使った回数（サバイバー視点）
      survivorFaced: {},  // サバイバーとして対戦した回数（ハンター視点）
      hunterUsed: {},     // ハンターとして使った回数（ハンター視点）
      hunterFaced: {}     // ハンターとして対戦した回数（サバイバー視点）
    };
    
    // キャラクター使用回数を増やす
    function incrementCharacterUsage(countType, characters) {
      if (!Array.isArray(characters)) {
        characters = [characters];
      }
      
      characters.forEach(char => {
        if (!char) return;
        
        if (!characterUsageCount[countType][char]) {
          characterUsageCount[countType][char] = 0;
        }
        characterUsageCount[countType][char]++;
      });
      
      saveCharacterUsageCount();
    }
    
    // キャラクター使用回数を減らす
    function decrementCharacterUsage(countType, characters) {
      if (!Array.isArray(characters)) {
        characters = [characters];
      }
      
      characters.forEach(char => {
        if (!char) return;
        
        if (characterUsageCount[countType][char]) {
          characterUsageCount[countType][char]--;
          
          // 0になったら削除
          if (characterUsageCount[countType][char] <= 0) {
            delete characterUsageCount[countType][char];
          }
        }
      });
      
      saveCharacterUsageCount();
    }
    
    // キャラクター使用回数をソート（使用回数順 → 配列定義順）
    function sortCharactersByUsage(characters, countType) {
      const usageData = characterUsageCount[countType] || {};
      
      return characters.slice().sort((a, b) => {
        const usageA = usageData[a] || 0;
        const usageB = usageData[b] || 0;
        
        // 使用回数が異なる場合は多い順
        if (usageA !== usageB) {
          return usageB - usageA;
        }
        
        // 使用回数が同じ場合は配列定義順を維持
        return characters.indexOf(a) - characters.indexOf(b);
      });
    }
    
    // キャラクター使用回数を保存
    function saveCharacterUsageCount() {
      localStorage.setItem('identity5_character_usage', JSON.stringify(characterUsageCount));
    }
    
    // キャラクター使用回数を読み込み
    function loadCharacterUsageCount() {
      const saved = localStorage.getItem('identity5_character_usage');
      if (saved) {
        try {
          const loadedData = JSON.parse(saved);
          
          // 新しいデータ構造かチェック
          if (loadedData.survivorUsed !== undefined) {
            // 新しい構造
            characterUsageCount = loadedData;
          } else {
            // 古い構造の場合、全試合データから再計算
            console.log('Migrating character usage count structure...');
            characterUsageCount = {
              survivorUsed: {},
              survivorFaced: {},
              hunterUsed: {},
              hunterFaced: {}
            };
            
            // 全試合データから使用回数を再計算（保存は最後に1回だけ）
            matches.forEach(match => {
              if (match.perspective === 'survivor') {
                // サバイバー使用回数
                const survivors = [match.myCharacter, ...match.teammates];
                survivors.forEach(char => {
                  if (!char) return;
                  if (!characterUsageCount.survivorUsed[char]) {
                    characterUsageCount.survivorUsed[char] = 0;
                  }
                  characterUsageCount.survivorUsed[char]++;
                });
                
                // ハンター対戦回数
                const hunter = match.opponentHunter;
                if (hunter) {
                  if (!characterUsageCount.hunterFaced[hunter]) {
                    characterUsageCount.hunterFaced[hunter] = 0;
                  }
                  characterUsageCount.hunterFaced[hunter]++;
                }
              } else {
                // ハンター使用回数
                const hunter = match.myCharacter;
                if (hunter) {
                  if (!characterUsageCount.hunterUsed[hunter]) {
                    characterUsageCount.hunterUsed[hunter] = 0;
                  }
                  characterUsageCount.hunterUsed[hunter]++;
                }
                
                // サバイバー対戦回数
                const survivors = match.opponentSurvivors;
                survivors.forEach(char => {
                  if (!char) return;
                  if (!characterUsageCount.survivorFaced[char]) {
                    characterUsageCount.survivorFaced[char] = 0;
                  }
                  characterUsageCount.survivorFaced[char]++;
                });
              }
            });
            
            // 再計算したデータを保存
            saveCharacterUsageCount();
          }
        } catch (e) {
          console.error('Failed to load character usage count:', e);
          characterUsageCount = {
            survivorUsed: {},
            survivorFaced: {},
            hunterUsed: {},
            hunterFaced: {}
          };
        }
      }
    }
    
    // キャラクター選択を再構築（使用回数順に更新）
    function repopulateCharacterSelects() {
      // サバイバー選択（自分・味方）：サバイバー使用回数順
      const mySurvivorSelects = ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3'];
      const sortedSurvivorsUsed = sortCharactersByUsage(SURVIVORS, 'survivorUsed');
      
      mySurvivorSelects.forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // オプションをクリア（最初の空白オプション以外）
        select.innerHTML = '<option value="">選択してください</option>';
        
        // ソート済みのキャラクターを追加
        sortedSurvivorsUsed.forEach(survivor => {
          const option = document.createElement('option');
          option.value = survivor;
          option.textContent = survivor;
          select.appendChild(option);
        });
        
        // 値を復元
        select.value = currentValue;
        
        // プレースホルダースタイルを更新
        updatePlaceholderStyle(select);
      });
      
      // サバイバー選択（相手）：サバイバー対戦回数順
      const opponentSurvivorSelects = ['opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'];
      const sortedSurvivorsFaced = sortCharactersByUsage(SURVIVORS, 'survivorFaced');
      
      opponentSurvivorSelects.forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // オプションをクリア（最初の空白オプション以外）
        select.innerHTML = '<option value="">選択してください</option>';
        
        // ソート済みのキャラクターを追加
        sortedSurvivorsFaced.forEach(survivor => {
          const option = document.createElement('option');
          option.value = survivor;
          option.textContent = survivor;
          select.appendChild(option);
        });
        
        // 値を復元
        select.value = currentValue;
        
        // プレースホルダースタイルを更新
        updatePlaceholderStyle(select);
      });
      
      // ハンター選択（自分）：ハンター使用回数順
      const myHunterSelect = document.getElementById('my-hunter');
      const myHunterCurrentValue = myHunterSelect.value;
      const sortedHuntersUsed = sortCharactersByUsage(HUNTERS, 'hunterUsed');
      
      myHunterSelect.innerHTML = '<option value="">選択してください</option>';
      sortedHuntersUsed.forEach(hunter => {
        const option = document.createElement('option');
        option.value = hunter;
        option.textContent = hunter;
        myHunterSelect.appendChild(option);
      });
      myHunterSelect.value = myHunterCurrentValue;
      updatePlaceholderStyle(myHunterSelect);
      
      // ハンター選択（相手）：ハンター対戦回数順
      const opponentHunterSelect = document.getElementById('opponent-hunter');
      const opponentHunterCurrentValue = opponentHunterSelect.value;
      const sortedHuntersFaced = sortCharactersByUsage(HUNTERS, 'hunterFaced');
      
      opponentHunterSelect.innerHTML = '<option value="">選択してください</option>';
      sortedHuntersFaced.forEach(hunter => {
        const option = document.createElement('option');
        option.value = hunter;
        option.textContent = hunter;
        opponentHunterSelect.appendChild(option);
      });
      opponentHunterSelect.value = opponentHunterCurrentValue;
      updatePlaceholderStyle(opponentHunterSelect);
      
      // SearchableSelectを同期
      ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3',
       'opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4',
       'my-hunter', 'opponent-hunter'].forEach(syncSearchableSelect);
    }
    
    // ページネーション用の変数
    let currentPages = {
      teammateStats: 1,
      opponentStats: 1,
      matchHistory: 1
    };
    const itemsPerPage = 20;
    
    // 並び替え状態管理
    // sortKey: 'winrate' | 'matches', sortOrder: 'desc' | 'asc'
    const sortState = {
      character:      { key: 'winrate', order: 'desc' },
      map:            { key: 'winrate', order: 'desc' },
      opponentHunter: { key: 'winrate', order: 'desc' },
      teammate:       { key: 'winrate', order: 'desc' },
      opponent:       { key: 'winrate', order: 'desc' }
    };
    
    // 並び替えキー切替
    function setSortKey(tab, key) {
      sortState[tab].key = key;
      updateAllStats();
    }
    
    // 並び替え順序切替
    function setSortOrder(tab, order) {
      sortState[tab].order = order;
      updateAllStats();
    }
    
    // 並び替えコントロールHTML生成
    function generateSortButtons(tab) {
      const state = sortState[tab];
      const wrActive = state.key === 'winrate' ? ' active' : '';
      const mcActive = state.key === 'matches' ? ' active' : '';
      const descActive = state.order === 'desc' ? ' active' : '';
      const ascActive = state.order === 'asc' ? ' active' : '';
      
      return `<div class="sort-control">
        <button class="sort-key-btn${wrActive}" onclick="setSortKey('${tab}', 'winrate')">勝率</button>
        <button class="sort-key-btn${mcActive}" onclick="setSortKey('${tab}', 'matches')">試合数</button>
        <div class="sort-divider"></div>
        <button class="sort-arrow-btn${descActive}" onclick="setSortOrder('${tab}', 'desc')">↓</button>
        <button class="sort-arrow-btn${ascActive}" onclick="setSortOrder('${tab}', 'asc')">↑</button>
      </div>`;
    }
    
    // 汎用ソート関数
    function sortByState(keys, statsMap, perspective, state) {
      return keys.sort((a, b) => {
        const statsA = calculateWinrate(statsMap[a], perspective);
        const statsB = calculateWinrate(statsMap[b], perspective);
        
        let primary, secondary;
        if (state.key === 'winrate') {
          primary = parseFloat(statsB.winrate) - parseFloat(statsA.winrate);
          secondary = statsB.totalWithDraws - statsA.totalWithDraws;
        } else {
          primary = statsB.totalWithDraws - statsA.totalWithDraws;
          secondary = parseFloat(statsB.winrate) - parseFloat(statsA.winrate);
        }
        
        if (state.order === 'asc') {
          primary = -primary;
          secondary = -secondary;
        }
        
        return primary !== 0 ? primary : secondary;
      });
    }
    
    // 初期化
    function init() {
      // ダークモード復元
      loadDarkMode();
      
      // データを先に読み込む
      loadData(); // データを読み込む
      loadCharacterUsageCount(); // 使用回数を読み込む（マイグレーション含む）
      
      // 使用回数データを元にキャラクター選択肢を構築
      populateSelects();
      populatePeriodFilters(); // 期間フィルターにシーズンを追加
      
      // キャラ選択を検索付きドロップダウンに変換
      initAllSearchableSelects();
      
      // プレースホルダースタイルを初期化（選択肢更新の前に実行）
      initializePlaceholderStyles();
      
      updateSurvivorSelects(); // サバイバー選択肢の初期化
      updateOpponentSurvivorSelects(); // 相手サバイバー選択肢の初期化
      
      // 保持された値を復元（DOM要素が完全に準備された後）
      loadPersistedValues('survivor');
      loadPersistedValues('hunter');
      
      // 日付フィールドの初期値を設定
      initializeDateFields();
      
      // 初期状態はサバイバー視点なので、対戦相手フィルターを表示
      const opponentFilterGroup = document.getElementById('opponent-filter-group');
      if (opponentFilterGroup) {
        opponentFilterGroup.style.display = 'block';
      }
      
      // 対戦相手ハンターフィルターを更新
      updateOpponentHunterFilter();
      updateHistoryOpponentFilter();
      
      // 自キャラ別勝率のマップフィルターを更新
      updateCharacterMapFilter();
      
      // タブのスクロール監視を初期化
      initializeTabScrollIndicator();
      
      updateAllWithFilters(); // フィルターと統計を更新
    }
    
    // サバイバー選択肢を更新（重複を除外）
    function updateSurvivorSelects() {
      const mySurvivor = document.getElementById('my-survivor').value;
      const teammate1 = document.getElementById('teammate-1').value;
      const teammate2 = document.getElementById('teammate-2').value;
      const teammate3 = document.getElementById('teammate-3').value;
      
      const selected = [mySurvivor, teammate1, teammate2, teammate3].filter(v => v);
      
      const selectIds = ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3'];
      
      // サバイバー使用回数順にソート
      const sortedSurvivors = sortCharactersByUsage(SURVIVORS, 'survivorUsed');
      
      selectIds.forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // 選択肢を再構築
        select.innerHTML = '<option value="">選択してください</option>';
        sortedSurvivors.forEach(survivor => {
          // 自分が選択中か、他で選択されていない場合のみ表示
          if (survivor === currentValue || !selected.includes(survivor)) {
            const option = document.createElement('option');
            option.value = survivor;
            option.textContent = survivor;
            select.appendChild(option);
          }
        });
        
        // 値を復元
        select.value = currentValue;
        
        // プレースホルダースタイルを更新
        updatePlaceholderStyle(select);
        
        // SearchableSelect同期
        syncSearchableSelect(id);
      });
    }
    
    // ハンター視点の相手サバイバー選択肢を更新（重複を除外）
    function updateOpponentSurvivorSelects() {
      const survivor1 = document.getElementById('opponent-survivor-1').value;
      const survivor2 = document.getElementById('opponent-survivor-2').value;
      const survivor3 = document.getElementById('opponent-survivor-3').value;
      const survivor4 = document.getElementById('opponent-survivor-4').value;
      
      const selected = [survivor1, survivor2, survivor3, survivor4].filter(v => v);
      
      const selectIds = ['opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'];
      
      // サバイバー対戦回数順にソート
      const sortedSurvivors = sortCharactersByUsage(SURVIVORS, 'survivorFaced');
      
      selectIds.forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // 選択肢を再構築
        select.innerHTML = '<option value="">選択してください</option>';
        sortedSurvivors.forEach(survivor => {
          // 自分が選択中か、他で選択されていない場合のみ表示
          if (survivor === currentValue || !selected.includes(survivor)) {
            const option = document.createElement('option');
            option.value = survivor;
            option.textContent = survivor;
            select.appendChild(option);
          }
        });
        
        // 値を復元
        select.value = currentValue;
        
        // プレースホルダースタイルを更新
        updatePlaceholderStyle(select);
        
        // SearchableSelect同期
        syncSearchableSelect(id);
      });
    }
    
    // セレクトボックスにオプションを追加
    function populateSelects() {
      // サバイバー選択（自分・味方）：サバイバー使用回数順にソート
      const mySurvivorSelects = ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3'];
      const sortedSurvivorsUsed = sortCharactersByUsage(SURVIVORS, 'survivorUsed');
      
      mySurvivorSelects.forEach(id => {
        const select = document.getElementById(id);
        sortedSurvivorsUsed.forEach(survivor => {
          const option = document.createElement('option');
          option.value = survivor;
          option.textContent = survivor;
          select.appendChild(option);
        });
      });
      
      // サバイバー選択（相手）：サバイバー対戦回数順にソート
      const opponentSurvivorSelects = ['opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'];
      const sortedSurvivorsFaced = sortCharactersByUsage(SURVIVORS, 'survivorFaced');
      
      opponentSurvivorSelects.forEach(id => {
        const select = document.getElementById(id);
        sortedSurvivorsFaced.forEach(survivor => {
          const option = document.createElement('option');
          option.value = survivor;
          option.textContent = survivor;
          select.appendChild(option);
        });
      });
      
      // ハンター選択（自分）：ハンター使用回数順にソート
      const myHunterSelect = document.getElementById('my-hunter');
      const sortedHuntersUsed = sortCharactersByUsage(HUNTERS, 'hunterUsed');
      
      sortedHuntersUsed.forEach(hunter => {
        const option = document.createElement('option');
        option.value = hunter;
        option.textContent = hunter;
        myHunterSelect.appendChild(option);
      });
      
      // ハンター選択（相手）：ハンター対戦回数順にソート
      const opponentHunterSelect = document.getElementById('opponent-hunter');
      const sortedHuntersFaced = sortCharactersByUsage(HUNTERS, 'hunterFaced');
      
      sortedHuntersFaced.forEach(hunter => {
        const option = document.createElement('option');
        option.value = hunter;
        option.textContent = hunter;
        opponentHunterSelect.appendChild(option);
      });
      
      const mapSelects = ['survivor-map', 'hunter-map'];
      mapSelects.forEach(id => {
        const select = document.getElementById(id);
        MAPS.forEach(map => {
          const option = document.createElement('option');
          option.value = map;
          option.textContent = map;
          select.appendChild(option);
        });
      });
      
      const rankSelects = ['survivor-rank', 'hunter-rank'];
      rankSelects.forEach(id => {
        const select = document.getElementById(id);
        RANKS.forEach(rank => {
          const option = document.createElement('option');
          option.value = rank;
          option.textContent = rank;
          select.appendChild(option);
        });
      });
      
      // サバイバー選択時の重複チェックを追加
      ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => updateSurvivorSelectOptions());
      });
      
      // ハンター視点のサバイバー選択時の重複チェックを追加
      ['opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => updateHunterOpponentSelectOptions());
      });
    }
    
    // 対戦相手ハンターフィルターを更新（実際に対戦したハンターのみ表示）
    function updateOpponentHunterFilter() {
      const opponentHunterFilter = document.getElementById('opponent-hunter-filter');
      if (!opponentHunterFilter) return;
      
      // 現在の選択値を保存
      const currentValue = opponentHunterFilter.value;
      
      // サバイバー視点の試合から対戦したハンターを抽出
      const survivorMatches = matches.filter(m => m.perspective === 'survivor');
      const encounteredHunters = new Set();
      
      survivorMatches.forEach(match => {
        if (match.opponentHunter) {
          encounteredHunters.add(match.opponentHunter);
        }
      });
      
      // 選択肢をクリア（「全て」以外）
      opponentHunterFilter.innerHTML = '<option value="all">全て</option>';
      
      // 実際に対戦したハンターのみ追加（配列定義順）
      const sortedHunters = HUNTERS.filter(hunter => encounteredHunters.has(hunter));
      sortedHunters.forEach(hunter => {
        const option = document.createElement('option');
        option.value = hunter;
        option.textContent = hunter;
        opponentHunterFilter.appendChild(option);
      });
      
      // 以前の選択値を復元（存在する場合）
      if (currentValue && (currentValue === 'all' || encounteredHunters.has(currentValue))) {
        opponentHunterFilter.value = currentValue;
      } else {
        opponentHunterFilter.value = 'all';
      }
    }
    
    // 自キャラ別勝率のマップフィルターを更新（実際に記録したマップのみ表示）
    function updateCharacterMapFilter() {
      const characterMapFilter = document.getElementById('character-map-filter');
      if (!characterMapFilter) return;
      
      // 現在の選択値を保存
      const currentValue = characterMapFilter.value;
      
      // 現在の視点の試合から記録されたマップを抽出
      const perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      const recordedMaps = new Set();
      
      perspectiveMatches.forEach(match => {
        if (match.map) {
          recordedMaps.add(match.map);
        }
      });
      
      // 選択肢をクリア（「全マップ」以外）
      characterMapFilter.innerHTML = '<option value="all">全マップ</option>';
      
      // 実際に記録したマップのみ追加（配列定義順）
      const sortedMaps = MAPS.filter(map => recordedMaps.has(map));
      sortedMaps.forEach(map => {
        const option = document.createElement('option');
        option.value = map;
        option.textContent = map;
        characterMapFilter.appendChild(option);
      });
      
      // 以前の選択値を復元（存在する場合）
      if (currentValue && (currentValue === 'all' || recordedMaps.has(currentValue))) {
        characterMapFilter.value = currentValue;
      } else {
        characterMapFilter.value = 'all';
      }
    }
    
    // 試合履歴の相手キャラフィルターを更新
    function updateHistoryOpponentFilter() {
      const filter = document.getElementById('history-opponent-filter');
      if (!filter) return;
      
      const currentValue = filter.value;
      const perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      const opponents = new Set();
      
      perspectiveMatches.forEach(match => {
        if (currentPerspective === 'survivor') {
          if (match.opponentHunter) opponents.add(match.opponentHunter);
        } else {
          if (match.opponentSurvivors) {
            match.opponentSurvivors.forEach(s => { if (s) opponents.add(s); });
          }
        }
      });
      
      filter.innerHTML = '<option value="all">全キャラ</option>';
      
      const charArray = currentPerspective === 'survivor' ? HUNTERS : SURVIVORS;
      const sorted = charArray.filter(c => opponents.has(c));
      sorted.forEach(c => {
        const option = document.createElement('option');
        option.value = c;
        option.textContent = c;
        filter.appendChild(option);
      });
      
      if (currentValue && (currentValue === 'all' || opponents.has(currentValue))) {
        filter.value = currentValue;
      } else {
        filter.value = 'all';
      }
    }
    
    // サバイバー視点：選択済みキャラを他の選択肢から除外
    function updateSurvivorSelectOptions() {
      const mySurvivor = document.getElementById('my-survivor').value;
      const teammate1 = document.getElementById('teammate-1').value;
      const teammate2 = document.getElementById('teammate-2').value;
      const teammate3 = document.getElementById('teammate-3').value;
      
      const selected = [mySurvivor, teammate1, teammate2, teammate3].filter(v => v);
      
      // サバイバー使用回数順にソート
      const sortedSurvivors = sortCharactersByUsage(SURVIVORS, 'survivorUsed');
      
      ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3'].forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // 選択肢を再構築
        select.innerHTML = '<option value="">選択してください</option>';
        sortedSurvivors.forEach(survivor => {
          // 自分以外で選択されているキャラは除外
          if (!selected.includes(survivor) || survivor === currentValue) {
            const option = document.createElement('option');
            option.value = survivor;
            option.textContent = survivor;
            select.appendChild(option);
          }
        });
        
        // 現在の値を復元
        select.value = currentValue;
        
        // プレースホルダースタイルを更新
        updatePlaceholderStyle(select);
        
        // SearchableSelect同期
        syncSearchableSelect(id);
      });
    }
    
    // ハンター視点：選択済みキャラを他の選択肢から除外
    function updateHunterOpponentSelectOptions() {
      const opponent1 = document.getElementById('opponent-survivor-1').value;
      const opponent2 = document.getElementById('opponent-survivor-2').value;
      const opponent3 = document.getElementById('opponent-survivor-3').value;
      const opponent4 = document.getElementById('opponent-survivor-4').value;
      
      const selected = [opponent1, opponent2, opponent3, opponent4].filter(v => v);
      
      // サバイバー対戦回数順にソート
      const sortedSurvivors = sortCharactersByUsage(SURVIVORS, 'survivorFaced');
      
      ['opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'].forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // 選択肢を再構築
        select.innerHTML = '<option value="">選択してください</option>';
        sortedSurvivors.forEach(survivor => {
          // 自分以外で選択されているキャラは除外
          if (!selected.includes(survivor) || survivor === currentValue) {
            const option = document.createElement('option');
            option.value = survivor;
            option.textContent = survivor;
            select.appendChild(option);
          }
        });
        
        // 現在の値を復元
        select.value = currentValue;
        
        // プレースホルダースタイルを更新
        updatePlaceholderStyle(select);
        
        // SearchableSelect同期
        syncSearchableSelect(id);
      });
    }
    
    // 段位フィルターを設定（使用済み段位のみ）
    function populateRankFilters() {
      const perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      const usedRanks = [...new Set(perspectiveMatches.map(m => m.rank).filter(r => r))];
      
      // RANKS配列の順序を保持してソート
      const sortedRanks = RANKS.filter(rank => usedRanks.includes(rank));
      
      const filterIds = ['character-rank-filter', 'map-rank-filter', 'opponent-rank-filter', 'history-rank-filter'];
      filterIds.forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        select.innerHTML = '<option value="all">全段位</option>';
        
        sortedRanks.forEach(rank => {
          const option = document.createElement('option');
          option.value = rank;
          option.textContent = rank;
          select.appendChild(option);
        });
        
        // 前回選択していた値を復元
        if (currentValue && (currentValue === 'all' || sortedRanks.includes(currentValue))) {
          select.value = currentValue;
        }
      });
      
      // マップフィルター（対戦相手別勝率用、自キャラフィルターに連動）
      const myCharFilterValue = document.getElementById('my-char-filter')?.value || 'all';
      updateMapFilter(myCharFilterValue);
      
      // 自キャラフィルター
      updateMyCharFilter();
    }
    
    // マップフィルターを更新（自キャラフィルターに連動）
    function updateMapFilter(selectedChar = 'all') {
      const perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      
      // 自キャラでフィルター
      let filteredMatches = perspectiveMatches;
      if (selectedChar !== 'all') {
        filteredMatches = perspectiveMatches.filter(m => m.myCharacter === selectedChar);
      }
      
      // 配列定義順にソート
      const usedMapsSet = new Set(filteredMatches.map(m => m.map));
      const usedMaps = MAPS.filter(map => usedMapsSet.has(map));
      
      const mapSelect = document.getElementById('opponent-map-filter');
      const currentValue = mapSelect.value;
      mapSelect.innerHTML = '<option value="all">全マップ</option>';
      usedMaps.forEach(map => {
        const option = document.createElement('option');
        option.value = map;
        option.textContent = map;
        mapSelect.appendChild(option);
      });
      
      // 前回選択していた値を復元（存在する場合のみ）
      if (currentValue && (currentValue === 'all' || usedMaps.includes(currentValue))) {
        mapSelect.value = currentValue;
      }
    }
    
    // 自キャラフィルターを更新（使用済みキャラのみ）
    function updateMyCharFilter() {
      const perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      const usedCharsSet = new Set(perspectiveMatches.map(m => m.myCharacter));
      
      // 配列定義順にソート（視点に応じて配列を選択）
      const characterArray = currentPerspective === 'survivor' ? SURVIVORS : HUNTERS;
      const usedChars = characterArray.filter(char => usedCharsSet.has(char));
      
      // 対戦相手別勝率のフィルター
      const opponentSelect = document.getElementById('my-char-filter');
      opponentSelect.innerHTML = '<option value="all">全キャラ</option>';
      usedChars.forEach(char => {
        const option = document.createElement('option');
        option.value = char;
        option.textContent = char;
        opponentSelect.appendChild(option);
      });
      
      // マップ別勝率のフィルター
      const mapSelect = document.getElementById('map-char-filter');
      mapSelect.innerHTML = '<option value="all">全キャラ</option>';
      usedChars.forEach(char => {
        const option = document.createElement('option');
        option.value = char;
        option.textContent = char;
        mapSelect.appendChild(option);
      });
    }
    
    // 視点を切り替え
    function switchPerspective(perspective) {
      currentPerspective = perspective;
      
      document.querySelectorAll('.perspective-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');
      
      if (perspective === 'survivor') {
        document.getElementById('survivor-input').style.display = 'block';
        document.getElementById('hunter-input').style.display = 'none';
        
        // サバイバー視点では対戦相手フィルターを表示
        const opponentFilterGroup = document.getElementById('opponent-filter-group');
        if (opponentFilterGroup) {
          opponentFilterGroup.style.display = 'block';
        }
      } else {
        document.getElementById('survivor-input').style.display = 'none';
        document.getElementById('hunter-input').style.display = 'block';
        
        // ハンター視点では対戦相手フィルターを非表示
        const opponentFilterGroup = document.getElementById('opponent-filter-group');
        if (opponentFilterGroup) {
          opponentFilterGroup.style.display = 'none';
        }
      }
      
      // 自キャラ別勝率のマップフィルターを更新（視点が変わったので）
      updateCharacterMapFilter();
      
      // 試合履歴の相手キャラフィルターを更新（視点が変わったので）
      updateHistoryOpponentFilter();
      
      // 総合勝率タブが表示されている場合は更新
      const overallTab = document.getElementById('overall-tab');
      if (overallTab && overallTab.classList.contains('active')) {
        updateOverallStatsTab();
      }
      
      updateAllWithFilters();
    }
    
    // タブを切り替え
    function switchTab(tabName) {
      document.querySelectorAll('.main-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');
      
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(tabName + '-tab').classList.add('active');
      
      // 設定タブに切り替えた時はデータ情報を更新
      if (tabName === 'settings') {
        updateDataInfo();
      }
      
      // 総合勝率タブに切り替えた時は総合勝率とグラフを更新
      if (tabName === 'overall') {
        updateOverallStatsTab();
      }
      
      updateAllStats();
    }
    
    // 脱出人数を選択
    function selectEscapeCount(perspective, count) {
      selectedEscapeCount[perspective] = count;
      
      const container = perspective === 'survivor' ? document.getElementById('survivor-input') : document.getElementById('hunter-input');
      container.querySelectorAll('.result-button').forEach(btn => {
        btn.classList.remove('selected');
      });
      event.target.classList.add('selected');
    }
    
    // 脱出人数から勝敗を判定
    function getResultFromEscapeCount(escapeCount, perspective) {
      if (perspective === 'survivor') {
        if (escapeCount >= 3) return 'survivor_win';
        if (escapeCount === 2) return 'draw';
        return 'hunter_win';
      } else {
        if (escapeCount <= 1) return 'hunter_win';
        if (escapeCount === 2) return 'draw';
        return 'survivor_win';
      }
    }
    
    // 試合を記録
    function submitMatch(perspective) {
      let match = {
        id: editingMatchId || Date.now(),
        perspective: perspective,
        timestamp: new Date().toISOString()
      };
      
      if (perspective === 'survivor') {
        const date = document.getElementById('survivor-date').value;
        const rank = document.getElementById('survivor-rank').value;
        const mySurvivor = document.getElementById('my-survivor').value;
        const teammate1 = document.getElementById('teammate-1').value;
        const teammate2 = document.getElementById('teammate-2').value;
        const teammate3 = document.getElementById('teammate-3').value;
        const opponentHunter = document.getElementById('opponent-hunter').value;
        const map = document.getElementById('survivor-map').value;
        const escapeCount = selectedEscapeCount.survivor;
        
        if (!date || !rank || !mySurvivor || !teammate1 || !teammate2 || !teammate3 || !opponentHunter || !map || escapeCount === null) {
          alert('全ての項目を入力してください');
          return;
        }
        
        match.date = date;
        match.rank = rank;
        match.myCharacter = mySurvivor;
        match.teammates = [teammate1, teammate2, teammate3];
        match.opponentHunter = opponentHunter;
        match.map = map;
        match.escapeCount = escapeCount;
        match.result = getResultFromEscapeCount(escapeCount, perspective);
      } else {
        const date = document.getElementById('hunter-date').value;
        const rank = document.getElementById('hunter-rank').value;
        const myHunter = document.getElementById('my-hunter').value;
        const opponentSurvivor1 = document.getElementById('opponent-survivor-1').value;
        const opponentSurvivor2 = document.getElementById('opponent-survivor-2').value;
        const opponentSurvivor3 = document.getElementById('opponent-survivor-3').value;
        const opponentSurvivor4 = document.getElementById('opponent-survivor-4').value;
        const map = document.getElementById('hunter-map').value;
        const escapeCount = selectedEscapeCount.hunter;
        
        if (!date || !rank || !myHunter || !opponentSurvivor1 || !opponentSurvivor2 || !opponentSurvivor3 || !opponentSurvivor4 || !map || escapeCount === null) {
          alert('全ての項目を入力してください');
          return;
        }
        
        match.date = date;
        match.rank = rank;
        match.myCharacter = myHunter;
        match.opponentSurvivors = [opponentSurvivor1, opponentSurvivor2, opponentSurvivor3, opponentSurvivor4];
        match.map = map;
        match.escapeCount = escapeCount;
        match.result = getResultFromEscapeCount(escapeCount, perspective);
      }
      
      if (editingMatchId) {
        // 編集モードの場合、古いデータの使用回数を減らす
        const oldMatch = matches.find(m => m.id === editingMatchId);
        if (oldMatch) {
          if (oldMatch.perspective === 'survivor') {
            // サバイバー視点：自分、味方3人の使用回数を減らす
            decrementCharacterUsage('survivorUsed', [oldMatch.myCharacter, ...oldMatch.teammates]);
            // 対戦相手ハンターの対戦回数を減らす
            decrementCharacterUsage('hunterFaced', oldMatch.opponentHunter);
          } else {
            // ハンター視点：自分の使用回数を減らす
            decrementCharacterUsage('hunterUsed', oldMatch.myCharacter);
            // 対戦相手サバイバー4人の対戦回数を減らす
            decrementCharacterUsage('survivorFaced', oldMatch.opponentSurvivors);
          }
        }
        
        matches = matches.filter(m => m.id !== editingMatchId);
        editingMatchId = null;
      }
      
      // 新しいデータの使用回数を増やす
      if (perspective === 'survivor') {
        // サバイバー視点：自分、味方3人の使用回数を増やす
        incrementCharacterUsage('survivorUsed', [match.myCharacter, ...match.teammates]);
        // 対戦相手ハンターの対戦回数を増やす
        incrementCharacterUsage('hunterFaced', match.opponentHunter);
      } else {
        // ハンター視点：自分の使用回数を増やす
        incrementCharacterUsage('hunterUsed', match.myCharacter);
        // 対戦相手サバイバー4人の対戦回数を増やす
        incrementCharacterUsage('survivorFaced', match.opponentSurvivors);
      }
      
      matches.push(match);
      saveData();
      
      // 保持設定を保存
      savePersistedValues(perspective);
      
      resetForm(perspective);
      
      // 対戦相手ハンターフィルターを更新
      updateOpponentHunterFilter();
      updateHistoryOpponentFilter();
      
      // 自キャラ別勝率のマップフィルターを更新
      updateCharacterMapFilter();
      
      // セレクトボックスを再構築（使用回数順に更新）
      repopulateCharacterSelects();
      
      alert('試合を記録しました！');
      updateAllWithFilters();
      
      // 総合勝率タブが表示されている場合は更新
      const overallTab = document.getElementById('overall-tab');
      if (overallTab && overallTab.classList.contains('active')) {
        updateOverallStatsTab();
      }
    }
    
    // フォームをリセット（保持設定に応じて）
    function resetForm(perspective) {
      if (perspective === 'survivor') {
        const fields = [
          { id: 'survivor-date', persistKey: 'persist-survivor-date', isDate: true },
          { id: 'survivor-rank', persistKey: 'persist-survivor-rank' },
          { id: 'my-survivor', persistKey: 'persist-my-survivor' },
          { id: 'teammate-1', persistKey: 'persist-teammate-1' },
          { id: 'teammate-2', persistKey: 'persist-teammate-2' },
          { id: 'teammate-3', persistKey: 'persist-teammate-3' },
          { id: 'opponent-hunter', persistKey: 'persist-opponent-hunter' },
          { id: 'survivor-map', persistKey: 'persist-survivor-map' }
        ];
        
        fields.forEach(field => {
          const persistCheckbox = document.getElementById(field.persistKey);
          const element = document.getElementById(field.id);
          
          // 保持チェックボックスがオフの場合のみクリア
          if (!persistCheckbox || !persistCheckbox.checked) {
            if (element) {
              if (field.isDate) {
                element.value = getToday(); // 日付は今日に戻す
              } else {
                element.value = '';
              }
            }
          }
        });
        
        selectedEscapeCount.survivor = null;
        document.querySelectorAll('#survivor-input .result-button').forEach(btn => {
          btn.classList.remove('selected');
        });
        updateSurvivorSelectOptions(); // 選択肢を更新
        // SearchableSelect同期
        ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3', 'opponent-hunter'].forEach(syncSearchableSelect);
      } else {
        const fields = [
          { id: 'hunter-date', persistKey: 'persist-hunter-date', isDate: true },
          { id: 'hunter-rank', persistKey: 'persist-hunter-rank' },
          { id: 'my-hunter', persistKey: 'persist-my-hunter' },
          { id: 'opponent-survivor-1', persistKey: 'persist-opponent-survivor-1' },
          { id: 'opponent-survivor-2', persistKey: 'persist-opponent-survivor-2' },
          { id: 'opponent-survivor-3', persistKey: 'persist-opponent-survivor-3' },
          { id: 'opponent-survivor-4', persistKey: 'persist-opponent-survivor-4' },
          { id: 'hunter-map', persistKey: 'persist-hunter-map' }
        ];
        
        fields.forEach(field => {
          const persistCheckbox = document.getElementById(field.persistKey);
          const element = document.getElementById(field.id);
          
          // 保持チェックボックスがオフの場合のみクリア
          if (!persistCheckbox || !persistCheckbox.checked) {
            if (element) {
              if (field.isDate) {
                element.value = getToday(); // 日付は今日に戻す
              } else {
                element.value = '';
              }
            }
          }
        });
        
        selectedEscapeCount.hunter = null;
        document.querySelectorAll('#hunter-input .result-button').forEach(btn => {
          btn.classList.remove('selected');
        });
        updateHunterOpponentSelectOptions(); // 選択肢を更新
        // SearchableSelect同期
        ['my-hunter', 'opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'].forEach(syncSearchableSelect);
      }
    }
    
    // データを保存
    function saveData() {
      localStorage.setItem('identity5_matches', JSON.stringify(matches));
    }
    
    // データを読み込み
    function loadData() {
      const saved = localStorage.getItem('identity5_matches');
      if (saved) {
        matches = JSON.parse(saved);
        
        // 既存データに日付がない場合、timestampから生成（マイグレーション）
        let migrated = false;
        matches = matches.map(match => {
          if (!match.date && match.timestamp) {
            const dateObj = new Date(match.timestamp);
            match.date = formatDate(dateObj);
            migrated = true;
          } else if (!match.date && match.id) {
            // timestampもない場合はidから生成
            const dateObj = new Date(match.id);
            match.date = formatDate(dateObj);
            migrated = true;
          }
          return match;
        });
        
        // マイグレーションした場合は保存
        if (migrated) {
          saveData();
        }
      }
    }
    
    // 保持された値を復元
    function loadPersistedValues(perspective) {
      try {
        if (perspective === 'survivor') {
          const fields = [
            { id: 'survivor-date', persistKey: 'persist-survivor-date', isDate: true },
            { id: 'survivor-rank', persistKey: 'persist-survivor-rank' },
            { id: 'my-survivor', persistKey: 'persist-my-survivor' },
            { id: 'teammate-1', persistKey: 'persist-teammate-1' },
            { id: 'teammate-2', persistKey: 'persist-teammate-2' },
            { id: 'teammate-3', persistKey: 'persist-teammate-3' },
            { id: 'opponent-hunter', persistKey: 'persist-opponent-hunter' },
            { id: 'survivor-map', persistKey: 'persist-survivor-map' }
          ];
          
          fields.forEach(field => {
            const persistCheckbox = document.getElementById(field.persistKey);
            const element = document.getElementById(field.id);
            const savedValue = localStorage.getItem(`persist_value_${field.id}`);
            const isChecked = localStorage.getItem(`persist_checkbox_${field.persistKey}`) === 'true';
            
            if (isChecked && persistCheckbox) {
              persistCheckbox.checked = true;
            }
            
            if (savedValue && element) {
              element.value = savedValue;
            } else if (field.isDate && element && !element.value) {
              // 日付フィールドで保持していない場合は今日の日付
              element.value = getToday();
            }
          });
        } else {
          const fields = [
            { id: 'hunter-date', persistKey: 'persist-hunter-date', isDate: true },
            { id: 'hunter-rank', persistKey: 'persist-hunter-rank' },
            { id: 'my-hunter', persistKey: 'persist-my-hunter' },
            { id: 'opponent-survivor-1', persistKey: 'persist-opponent-survivor-1' },
            { id: 'opponent-survivor-2', persistKey: 'persist-opponent-survivor-2' },
            { id: 'opponent-survivor-3', persistKey: 'persist-opponent-survivor-3' },
            { id: 'opponent-survivor-4', persistKey: 'persist-opponent-survivor-4' },
            { id: 'hunter-map', persistKey: 'persist-hunter-map' }
          ];
          
          fields.forEach(field => {
            const persistCheckbox = document.getElementById(field.persistKey);
            const element = document.getElementById(field.id);
            const savedValue = localStorage.getItem(`persist_value_${field.id}`);
            const isChecked = localStorage.getItem(`persist_checkbox_${field.persistKey}`) === 'true';
            
            if (isChecked && persistCheckbox) {
              persistCheckbox.checked = true;
            }
            
            if (savedValue && element) {
              element.value = savedValue;
            } else if (field.isDate && element && !element.value) {
              // 日付フィールドで保持していない場合は今日の日付
              element.value = getToday();
            }
          });
        }
      } catch (error) {
        console.error('Error loading persisted values:', error);
      }
      
      // SearchableSelect同期
      if (perspective === 'survivor') {
        ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3', 'opponent-hunter'].forEach(syncSearchableSelect);
      } else {
        ['my-hunter', 'opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'].forEach(syncSearchableSelect);
      }
    }
    
    // 保持設定を保存
    function savePersistedValues(perspective) {
      try {
        if (perspective === 'survivor') {
          const fields = [
            { id: 'survivor-date', persistKey: 'persist-survivor-date' },
            { id: 'survivor-rank', persistKey: 'persist-survivor-rank' },
            { id: 'my-survivor', persistKey: 'persist-my-survivor' },
            { id: 'teammate-1', persistKey: 'persist-teammate-1' },
            { id: 'teammate-2', persistKey: 'persist-teammate-2' },
            { id: 'teammate-3', persistKey: 'persist-teammate-3' },
            { id: 'opponent-hunter', persistKey: 'persist-opponent-hunter' },
            { id: 'survivor-map', persistKey: 'persist-survivor-map' }
          ];
          
          fields.forEach(field => {
            const persistCheckbox = document.getElementById(field.persistKey);
            const element = document.getElementById(field.id);
            
            if (persistCheckbox && persistCheckbox.checked) {
              localStorage.setItem(`persist_checkbox_${field.persistKey}`, 'true');
              if (element) {
                localStorage.setItem(`persist_value_${field.id}`, element.value);
              }
            } else {
              localStorage.removeItem(`persist_checkbox_${field.persistKey}`);
              localStorage.removeItem(`persist_value_${field.id}`);
            }
          });
        } else {
          const fields = [
            { id: 'hunter-date', persistKey: 'persist-hunter-date' },
            { id: 'hunter-rank', persistKey: 'persist-hunter-rank' },
            { id: 'my-hunter', persistKey: 'persist-my-hunter' },
            { id: 'opponent-survivor-1', persistKey: 'persist-opponent-survivor-1' },
            { id: 'opponent-survivor-2', persistKey: 'persist-opponent-survivor-2' },
            { id: 'opponent-survivor-3', persistKey: 'persist-opponent-survivor-3' },
            { id: 'opponent-survivor-4', persistKey: 'persist-opponent-survivor-4' },
            { id: 'hunter-map', persistKey: 'persist-hunter-map' }
          ];
          
          fields.forEach(field => {
            const persistCheckbox = document.getElementById(field.persistKey);
            const element = document.getElementById(field.id);
            
            if (persistCheckbox && persistCheckbox.checked) {
              localStorage.setItem(`persist_checkbox_${field.persistKey}`, 'true');
              if (element) {
                localStorage.setItem(`persist_value_${field.id}`, element.value);
              }
            } else {
              localStorage.removeItem(`persist_checkbox_${field.persistKey}`);
              localStorage.removeItem(`persist_value_${field.id}`);
            }
          });
        }
      } catch (error) {
        console.error('Error saving persisted values:', error);
      }
    }
    
    // 全ての保持設定をクリア（確認なし）
    function clearAllPersistence(perspective) {
      console.log('clearAllPersistence called with perspective:', perspective);
      
      try {
        console.log('Clearing persistence immediately...');
        
        if (perspective === 'survivor') {
          const fields = [
            { id: 'survivor-date', persistKey: 'persist-survivor-date', isDate: true },
            { id: 'survivor-rank', persistKey: 'persist-survivor-rank' },
            { id: 'my-survivor', persistKey: 'persist-my-survivor' },
            { id: 'teammate-1', persistKey: 'persist-teammate-1' },
            { id: 'teammate-2', persistKey: 'persist-teammate-2' },
            { id: 'teammate-3', persistKey: 'persist-teammate-3' },
            { id: 'opponent-hunter', persistKey: 'persist-opponent-hunter' },
            { id: 'survivor-map', persistKey: 'persist-survivor-map' }
          ];
          
          fields.forEach(field => {
            const persistCheckbox = document.getElementById(field.persistKey);
            const element = document.getElementById(field.id);
            
            console.log(`Processing field: ${field.id}, checkbox found: ${!!persistCheckbox}, element found: ${!!element}`);
            
            if (persistCheckbox) {
              persistCheckbox.checked = false;
            }
            
            if (element) {
              if (field.isDate) {
                element.value = getToday(); // 日付は今日に戻す
              } else {
                element.value = '';
                // selectの場合、プレースホルダースタイルを更新
                if (element.tagName === 'SELECT') {
                  updatePlaceholderStyle(element);
                }
              }
            }
            
            localStorage.removeItem(`persist_checkbox_${field.persistKey}`);
            localStorage.removeItem(`persist_value_${field.id}`);
          });
          
          // 選択肢を更新
          updateSurvivorSelectOptions();
          // SearchableSelect同期
          ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3', 'opponent-hunter'].forEach(syncSearchableSelect);
          
          console.log('Survivor persistence cleared successfully');
        } else {
          const fields = [
            { id: 'hunter-date', persistKey: 'persist-hunter-date', isDate: true },
            { id: 'hunter-rank', persistKey: 'persist-hunter-rank' },
            { id: 'my-hunter', persistKey: 'persist-my-hunter' },
            { id: 'opponent-survivor-1', persistKey: 'persist-opponent-survivor-1' },
            { id: 'opponent-survivor-2', persistKey: 'persist-opponent-survivor-2' },
            { id: 'opponent-survivor-3', persistKey: 'persist-opponent-survivor-3' },
            { id: 'opponent-survivor-4', persistKey: 'persist-opponent-survivor-4' },
            { id: 'hunter-map', persistKey: 'persist-hunter-map' }
          ];
          
          fields.forEach(field => {
            const persistCheckbox = document.getElementById(field.persistKey);
            const element = document.getElementById(field.id);
            
            console.log(`Processing field: ${field.id}, checkbox found: ${!!persistCheckbox}, element found: ${!!element}`);
            
            if (persistCheckbox) {
              persistCheckbox.checked = false;
            }
            
            if (element) {
              if (field.isDate) {
                element.value = getToday(); // 日付は今日に戻す
              } else {
                element.value = '';
                // selectの場合、プレースホルダースタイルを更新
                if (element.tagName === 'SELECT') {
                  updatePlaceholderStyle(element);
                }
              }
            }
            
            localStorage.removeItem(`persist_checkbox_${field.persistKey}`);
            localStorage.removeItem(`persist_value_${field.id}`);
          });
          
          // 選択肢を更新
          updateHunterOpponentSelectOptions();
          // SearchableSelect同期
          ['my-hunter', 'opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'].forEach(syncSearchableSelect);
          
          console.log('Hunter persistence cleared successfully');
        }
      } catch (error) {
        console.error('Error clearing persistence:', error);
      }
    }
    
    // 入力値を保存
    // フィルタリングされたデータを取得
    function getFilteredMatches(rankFilter) {
      let filtered = matches.filter(m => m.perspective === currentPerspective);
      if (rankFilter && rankFilter !== 'all') {
        filtered = filtered.filter(m => m.rank === rankFilter);
      }
      return filtered;
    }
    
    // 自キャラフィルター変更時の処理
    function onMyCharFilterChange() {
      const selectedChar = document.getElementById('my-char-filter').value;
      updateMapFilter(selectedChar);
      updateAllStats();
    }
    
    // 全ての統計を更新
    function updateAllStats() {
      updateCharacterStats();
      updateMapStats();
      updateOpponentStats();
      updateMatchHistory();
    }
    
    // フィルター変更時にページをリセット
    function resetPagination() {
      currentPages.teammateStats = 1;
      currentPages.opponentStats = 1;
      currentPages.matchHistory = 1;
    }
    
    // フィルターを含む全てを更新
    function updateAllWithFilters() {
      resetPagination();
      populateRankFilters();
      updateAllStats();
    }
    
    // 勝率を計算
    function calculateWinrate(matches, perspective) {
      const totalWithDraws = matches.length; // 引き分けを含む総試合数
      const filtered = matches.filter(m => m.result !== 'draw');
      if (filtered.length === 0) return { wins: 0, losses: 0, draws: totalWithDraws, winrate: '0.0', total: 0, totalWithDraws: totalWithDraws };
      
      const wins = filtered.filter(m => {
        if (perspective === 'survivor') {
          return m.result === 'survivor_win';
        } else {
          return m.result === 'hunter_win';
        }
      }).length;
      
      const losses = filtered.length - wins;
      const draws = matches.filter(m => m.result === 'draw').length;
      const winrate = (wins / filtered.length * 100).toFixed(1);
      
      return { wins, losses, draws, winrate, total: filtered.length, totalWithDraws: totalWithDraws };
    }
    
    // 連勝数を計算
    function calculateWinStreak(matches, perspective) {
      if (matches.length === 0) return 0;
      
      // 最新の試合から遡る
      const sorted = [...matches].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      let streak = 0;
      
      for (const match of sorted) {
        if (match.result === 'draw') continue; // 引き分けは無視
        
        const isWin = (perspective === 'survivor' && match.result === 'survivor_win') || 
                      (perspective === 'hunter' && match.result === 'hunter_win');
        
        if (isWin) {
          streak++;
        } else {
          break;
        }
      }
      
      return streak;
    }
    
    // 平均脱出/脱落人数を計算
    function calculateAverageEscapeCount(matches, perspective) {
      if (matches.length === 0) return 0;
      
      const total = matches.reduce((sum, m) => sum + (m.escapeCount || 0), 0);
      return (total / matches.length).toFixed(1);
    }
    
    // 総合勝率を更新（試合入力タブ内）
    function updateOverallStats() {
      const container = document.getElementById('overall-stats-inline');
      let perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '';
        return;
      }
      
      // 期間フィルターを取得
      const periodFilter = document.getElementById('input-period-filter');
      const periodValue = periodFilter ? periodFilter.value : 'all';
      
      // 期間でフィルタリング
      let displayMatches = perspectiveMatches;
      if (periodValue === 'recent100') {
        // 百戦勝率
        displayMatches = perspectiveMatches.slice(-100);
      } else if (periodValue !== 'all') {
        // シーズンフィルター
        displayMatches = filterByPeriod(perspectiveMatches, periodValue);
      }
      
      const stats = calculateWinrate(displayMatches, currentPerspective);
      const streak = calculateWinStreak(perspectiveMatches, currentPerspective); // 連勝は全期間で計算
      
      // 小数点第二位まで計算
      const filtered = displayMatches.filter(m => m.result !== 'draw');
      const winrateDecimal = filtered.length > 0 ? 
        (stats.wins / filtered.length * 100).toFixed(2) : '0.00';
      
      // タイトルを決定
      let statsTitle = '総合勝率';
      if (periodValue === 'recent100') {
        statsTitle = '百戦勝率';
      } else if (periodValue !== 'all') {
        // シーズンの場合
        const season = SEASONS.find(s => s.id === periodValue);
        if (season) {
          statsTitle = `総合勝率（${season.label}）`;
        }
      }
      
      // 百戦勝率モードでは試合数を表示しない
      const matchCountText = periodValue === 'recent100' ? '' : ` (${stats.totalWithDraws}試合)`;
      
      let html = `<div class="stats-card" style="margin-bottom: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <div style="font-size: 14px; font-weight: 600; color: #666;">${statsTitle}</div>
        </div>
        <div class="overall-stats-display">
          <div class="winrate-big">${winrateDecimal}%</div>
          <div class="record-text">${stats.wins}勝 ${stats.losses}敗 ${stats.draws}分${matchCountText}</div>`;
      
      if (streak >= 2) {
        html += `<div class="streak-badge"><span class="streak-icon">🔥</span>${streak}連勝中！</div>`;
      }
      
      html += `</div></div>`;
      container.innerHTML = html;
    }
    
    // 総合勝率タブの更新
    let winrateChart = null; // グラフのインスタンスを保持
    
    function updateOverallStatsTab() {
      const container = document.getElementById('overall-stats-display');
      let perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        // グラフも空にする
        if (winrateChart) {
          winrateChart.destroy();
          winrateChart = null;
        }
        return;
      }
      
      // 期間フィルターを取得
      const periodFilter = document.getElementById('overall-period-filter');
      const periodValue = periodFilter ? periodFilter.value : 'all';
      
      // 期間でフィルタリング
      let displayMatches = perspectiveMatches;
      if (periodValue === 'recent100') {
        // 百戦勝率
        displayMatches = perspectiveMatches.slice(-100);
      } else if (periodValue !== 'all') {
        // シーズンフィルター
        displayMatches = filterByPeriod(perspectiveMatches, periodValue);
      }
      
      const stats = calculateWinrate(displayMatches, currentPerspective);
      const streak = calculateWinStreak(perspectiveMatches, currentPerspective); // 連勝は全期間で計算
      
      // 小数点第二位まで計算
      const filtered = displayMatches.filter(m => m.result !== 'draw');
      const winrateDecimal = filtered.length > 0 ? 
        (stats.wins / filtered.length * 100).toFixed(2) : '0.00';
      
      // タイトルを決定
      let statsTitle = '総合勝率';
      if (periodValue === 'recent100') {
        statsTitle = '百戦勝率';
      } else if (periodValue !== 'all') {
        // シーズンの場合
        const season = SEASONS.find(s => s.id === periodValue);
        if (season) {
          statsTitle = `総合勝率（${season.label}）`;
        }
      }
      
      // 百戦勝率モードでは試合数を表示しない
      const matchCountText = periodValue === 'recent100' ? '' : ` (${stats.totalWithDraws}試合)`;
      
      let html = `<div class="stats-card">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <div style="font-size: 14px; font-weight: 600; color: #666;">${statsTitle}</div>
        </div>
        <div class="overall-stats-display">
          <div class="winrate-big">${winrateDecimal}%</div>
          <div class="record-text">${stats.wins}勝 ${stats.losses}敗 ${stats.draws}分${matchCountText}</div>`;
      
      if (streak >= 2) {
        html += `<div class="streak-badge"><span class="streak-icon">🔥</span>${streak}連勝中！</div>`;
      }
      
      html += `</div></div>`;
      container.innerHTML = html;
      
      // グラフを更新
      updateWinrateChart(perspectiveMatches);
    }
    
    // 直近10試合の勝率推移グラフを描画
    function updateWinrateChart(perspectiveMatches) {
      try {
        // Chart.jsが読み込まれているか確認
        if (typeof Chart === 'undefined') {
          console.error('Chart.js is not loaded');
          return;
        }
        
        const canvas = document.getElementById('winrate-chart');
        if (!canvas) {
          console.error('Canvas element not found');
          return;
        }
        
        // 直近10試合を取得
        const recentMatches = perspectiveMatches.slice(-10);
        
        if (recentMatches.length === 0) {
          // データがない場合
          if (winrateChart) {
            winrateChart.destroy();
            winrateChart = null;
          }
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          return;
        }
        
        // 累積勝率を計算
        const labels = [];
        const data = [];
        
        recentMatches.forEach((match, index) => {
          // 引き分けを除いた勝率を計算
          const matchesExcludingDraws = recentMatches.slice(0, index + 1).filter(m => m.result !== 'draw');
          const winsCount = matchesExcludingDraws.filter(m => 
            (currentPerspective === 'survivor' && m.result === 'survivor_win') || 
            (currentPerspective === 'hunter' && m.result === 'hunter_win')
          ).length;
          
          const winrate = matchesExcludingDraws.length > 0 ? 
            (winsCount / matchesExcludingDraws.length * 100) : 0;
          
          labels.push(`${index + 1}試合目`);
          data.push(winrate.toFixed(2));
        });
        
        // 既存のグラフを破棄
        if (winrateChart) {
          winrateChart.destroy();
          winrateChart = null;
        }
        
        // 新しいグラフを作成
        const ctx = canvas.getContext('2d');
        const isDark = document.body.classList.contains('dark-mode');
        const tickColor = isDark ? '#9ca3af' : '#666';
        const gridColor = isDark ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.05)';
        const pointBorder = isDark ? '#222238' : '#fff';
        
        winrateChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: '勝率 (%)',
              data: data,
              borderColor: '#3b82f6',
              backgroundColor: isDark ? 'rgba(59, 130, 246, 0.15)' : 'rgba(59, 130, 246, 0.1)',
              tension: 0.4,
              fill: true,
              pointRadius: 4,
              pointHoverRadius: 6,
              pointBackgroundColor: '#3b82f6',
              pointBorderColor: pointBorder,
              pointBorderWidth: 2
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    return '勝率: ' + context.parsed.y + '%';
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                ticks: {
                  color: tickColor,
                  callback: function(value) {
                    return value + '%';
                  }
                },
                grid: {
                  color: gridColor
                }
              },
              x: {
                ticks: {
                  color: tickColor
                },
                grid: {
                  display: false
                }
              }
            }
          }
        });
      } catch (error) {
        console.error('Error creating chart:', error);
        // エラーが発生してもアプリは動作し続ける
      }
    }
    
    // ページネーションのHTMLを生成
    function generatePagination(currentPage, totalPages, onPageChange) {
      if (totalPages <= 1) return '';
      
      let html = '<div style="display: flex; flex-direction: column; gap: 10px; align-items: center; margin-top: 20px; padding: 15px;">';
      
      // 前へ/次へボタン + ページ情報
      html += '<div style="display: flex; gap: 10px; align-items: center;">';
      
      // 前へボタン
      if (currentPage > 1) {
        html += `<button onclick="${onPageChange}(${currentPage - 1})" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">← 前へ</button>`;
      } else {
        html += `<button disabled style="padding: 8px 16px; background: #d1d5db; color: #9ca3af; border: none; border-radius: 6px; font-size: 14px; font-weight: 600;">← 前へ</button>`;
      }
      
      // ページ情報
      html += `<span style="font-size: 14px; color: #666; font-weight: 600;">ページ ${currentPage} / ${totalPages}</span>`;
      
      // 次へボタン
      if (currentPage < totalPages) {
        html += `<button onclick="${onPageChange}(${currentPage + 1})" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">次へ →</button>`;
      } else {
        html += `<button disabled style="padding: 8px 16px; background: #d1d5db; color: #9ca3af; border: none; border-radius: 6px; font-size: 14px; font-weight: 600;">次へ →</button>`;
      }
      
      html += '</div>';
      
      // ページ番号ボタン
      html += '<div style="display: flex; gap: 5px; flex-wrap: wrap; justify-content: center;">';
      
      const maxButtons = 7; // 表示する最大ボタン数
      let startPage = Math.max(1, currentPage - Math.floor(maxButtons / 2));
      let endPage = Math.min(totalPages, startPage + maxButtons - 1);
      
      if (endPage - startPage < maxButtons - 1) {
        startPage = Math.max(1, endPage - maxButtons + 1);
      }
      
      // 最初のページ
      if (startPage > 1) {
        html += `<button onclick="${onPageChange}(1)" style="padding: 6px 12px; background: white; color: #3b82f6; border: 1px solid #3b82f6; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600;">1</button>`;
        if (startPage > 2) {
          html += `<span style="padding: 6px; color: #999;">...</span>`;
        }
      }
      
      // ページ番号ボタン
      for (let i = startPage; i <= endPage; i++) {
        if (i === currentPage) {
          html += `<button style="padding: 6px 12px; background: #3b82f6; color: white; border: 1px solid #3b82f6; border-radius: 4px; font-size: 13px; font-weight: 600;">${i}</button>`;
        } else {
          html += `<button onclick="${onPageChange}(${i})" style="padding: 6px 12px; background: white; color: #3b82f6; border: 1px solid #3b82f6; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600;">${i}</button>`;
        }
      }
      
      // 最後のページ
      if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
          html += `<span style="padding: 6px; color: #999;">...</span>`;
        }
        html += `<button onclick="${onPageChange}(${totalPages})" style="padding: 6px 12px; background: white; color: #3b82f6; border: 1px solid #3b82f6; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600;">${totalPages}</button>`;
      }
      
      html += '</div>';
      html += '</div>';
      
      return html;
    }
    
    // ページ変更関数
    function changeTeammatePage(page) {
      currentPages.teammateStats = page;
      updateOpponentStats();
    }
    
    function changeOpponentPage(page) {
      currentPages.opponentStats = page;
      updateOpponentStats();
    }
    
    function changeHistoryPage(page) {
      currentPages.matchHistory = page;
      updateMatchHistory();
    }
    
    // 苦手要素を検出する汎用関数
    function detectWeaknesses(statsData, minMatches = 5) {
      const threshold = currentPerspective === 'hunter' ? 50 : 38;
      const results = [];
      
      Object.keys(statsData).forEach(key => {
        const matches = statsData[key];
        if (matches.length < minMatches) return; // 最小試合数未満は除外
        
        const stats = calculateWinrate(matches, currentPerspective);
        const winrate = parseFloat(stats.winrate);
        
        results.push({
          name: key,
          winrate: winrate,
          stats: stats
        });
      });
      
      // 勝率が低い順にソート
      results.sort((a, b) => a.winrate - b.winrate);
      
      // 基準以下のものを抽出
      const belowThreshold = results.filter(r => r.winrate <= threshold);
      
      if (belowThreshold.length > 0) {
        // 基準以下のものがあれば上位5つまで
        return belowThreshold.slice(0, 5);
      } else if (results.length > 0) {
        // 基準以下がなければ最も低いもの1つ
        return [results[0]];
      } else {
        // データなし
        return [];
      }
    }
    
    // 苦手要素のHTMLを生成
    function generateWeaknessHTML(weaknesses, title) {
      if (weaknesses.length === 0) return '';
      
      let html = `<div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 12px 15px; margin: 15px 0; border-radius: 6px;">
        <div style="font-size: 13px; font-weight: 600; color: #92400e; margin-bottom: 8px;">${title}</div>
        <div style="font-size: 12px; color: #78350f;">`;
      
      weaknesses.forEach((item, index) => {
        html += `${index + 1}. ${item.name} <span style="font-weight: 600;">${item.stats.winrate}%</span> <span style="color: #a16207;">(${item.stats.wins}勝${item.stats.losses}敗${item.stats.draws}分)</span>`;
        if (index < weaknesses.length - 1) html += '<br>';
      });
      
      html += `</div></div>`;
      return html;
    }
    
    // 苦手要素を検出
    function detectWeaknesses(data, minMatches = 5) {
      const threshold = currentPerspective === 'hunter' ? 50 : 38;
      const weaknesses = [];
      
      Object.keys(data).forEach(key => {
        const matches = data[key];
        if (matches.length >= minMatches) {
          const stats = calculateWinrate(matches, currentPerspective);
          const winrate = parseFloat(stats.winrate) || 0;
          
          weaknesses.push({
            name: key,
            winrate: winrate,
            stats: stats
          });
        }
      });
      
      // 閾値以下のものをフィルター
      let filtered = weaknesses.filter(w => w.winrate <= threshold);
      
      // 該当なしの場合は最も低いものを返す
      if (filtered.length === 0 && weaknesses.length > 0) {
        weaknesses.sort((a, b) => a.winrate - b.winrate);
        filtered = [weaknesses[0]];
      } else {
        // 勝率が低い順にソート
        filtered.sort((a, b) => a.winrate - b.winrate);
      }
      
      return filtered.slice(0, 5); // 上位5つ
    }
    
    // 苦手要素を検出
    function detectWeaknesses(stats, minGames = 5) {
      const threshold = currentPerspective === 'hunter' ? 50 : 38;
      
      // ステップ1：有効なデータを抽出（5試合以上）
      const validData = [];
      Object.keys(stats).forEach(key => {
        const matches = stats[key];
        if (matches.length >= minGames) {
          const result = calculateWinrate(matches, currentPerspective);
          const winrate = parseFloat(result.winrate);
          
          validData.push({
            name: key,
            winrate: winrate,
            wins: result.wins,
            losses: result.losses,
            draws: result.draws,
            total: result.totalWithDraws,
            stats: result
          });
        }
      });
      
      // ステップ2：有効データが3つ未満なら空配列を返す（表示しない）
      if (validData.length < 3) {
        return [];
      }
      
      // ステップ3：閾値以下のデータを抽出
      const belowThreshold = validData.filter(d => d.winrate <= threshold);
      
      // ステップ4：閾値以下のデータがある場合
      if (belowThreshold.length > 0) {
        // 勝率が低い順にソートして最大5つ返す
        return belowThreshold.sort((a, b) => a.winrate - b.winrate).slice(0, 5);
      }
      
      // ステップ5：閾値以下がない場合、最も低いもの1つだけ返す（ただし100%は除外）
      const sortedData = validData.sort((a, b) => a.winrate - b.winrate);
      
      // 最も低いものが100%の場合は表示しない
      if (sortedData.length > 0 && sortedData[0].winrate === 100) {
        return [];
      }
      
      return sortedData.slice(0, 1);
    }
    
    // 苦手要素表示HTMLを生成（控えめなデザイン）
    function generateWeaknessHTML(weaknesses, title, icon) {
      if (weaknesses.length === 0) return '';
      
      const threshold = currentPerspective === 'hunter' ? 50 : 38;
      const hasWeakness = weaknesses.some(w => w.winrate <= threshold);
      const displayTitle = `苦手${title}`;
      
      let html = `
        <div class="weakness-card">
          <div class="weakness-title">${displayTitle}</div>
          <div style="display: flex; flex-direction: column; gap: 6px;">
      `;
      
      weaknesses.forEach((item, index) => {
        const isWeak = item.winrate <= threshold;
        html += `
          <div style="display: flex; justify-content: space-between; align-items: center; font-size: 13px;">
            <div>
              <span class="weakness-name">${index + 1}. ${item.name}</span>
              <span class="weakness-count">(${item.total}試合)</span>
            </div>
            <div class="weakness-rate${isWeak ? ' weak' : ''}">${item.winrate.toFixed(1)}%</div>
          </div>
        `;
      });
      
      html += `</div></div>`;
      return html;
    }
    
    // 自キャラ別勝率を更新
    function updateCharacterStats() {
      const container = document.getElementById('character-stats');
      const periodFilter = document.getElementById('character-period-filter').value;
      const rankFilter = document.getElementById('character-rank-filter').value;
      const mapFilter = document.getElementById('character-map-filter').value;
      let perspectiveMatches = getFilteredMatches(rankFilter);
      
      // 期間でフィルター
      perspectiveMatches = filterByPeriod(perspectiveMatches, periodFilter);
      
      // マップでフィルター
      if (mapFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => m.map === mapFilter);
      }
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        return;
      }
      
      const characterStats = {};
      
      perspectiveMatches.forEach(match => {
        const char = match.myCharacter;
        if (!characterStats[char]) {
          characterStats[char] = [];
        }
        characterStats[char].push(match);
      });
      
      // 苦手キャラクターを検出
      const weakCharacters = detectWeaknesses(characterStats);
      
      const sortedChars = sortByState(Object.keys(characterStats), characterStats, currentPerspective, sortState.character);
      
      let html = '';
      
      // 苦手キャラクターを表示
      html += generateWeaknessHTML(weakCharacters, 'キャラクター', '👤');
      
      // 並び替えボタン
      html += generateSortButtons('character');
      
      html += `<div class="stats-card">
        <div class="stats-title">キャラクター別勝率（${currentPerspective === 'survivor' ? 'サバイバー' : 'ハンター'}）</div>
        <div class="bar-chart-horizontal">`;
      
      sortedChars.forEach(char => {
        const stats = calculateWinrate(characterStats[char], currentPerspective);
        const avgEscape = calculateAverageEscapeCount(characterStats[char], currentPerspective);
        const winrateNum = parseFloat(stats.winrate) || 0;
        const barWidth = winrateNum;
        
        const avgText = currentPerspective === 'survivor' 
          ? `平均脱出${avgEscape}人` 
          : `平均脱落${(4 - parseFloat(avgEscape)).toFixed(1)}人`;
        
        const isZero = winrateNum === 0;
        
        html += `
          <div class="bar-row">
            <div class="bar-label-wrapper">
              <div class="bar-label">${char}</div>
              <div class="bar-sublabel">${avgText}<br>${stats.totalWithDraws}試合</div>
            </div>
            <div class="bar-wrapper">
              ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
              <div class="bar-visual" style="width: ${barWidth}%;">
                <div class="bar-value">${stats.winrate}%</div>
              </div>`}
            </div>
          </div>
        `;
      });
      
      html += '</div></div>';
      container.innerHTML = html;
    }
    
    // マップ別勝率を更新
    function updateMapStats() {
      const container = document.getElementById('map-stats');
      const periodFilter = document.getElementById('map-period-filter').value;
      const rankFilter = document.getElementById('map-rank-filter').value;
      const charFilter = document.getElementById('map-char-filter').value;
      let perspectiveMatches = getFilteredMatches(rankFilter);
      
      // 期間でフィルター
      perspectiveMatches = filterByPeriod(perspectiveMatches, periodFilter);
      
      // 自キャラでフィルター
      if (charFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => m.myCharacter === charFilter);
      }
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        return;
      }
      
      const mapStats = {};
      
      perspectiveMatches.forEach(match => {
        const map = match.map;
        if (!mapStats[map]) {
          mapStats[map] = [];
        }
        mapStats[map].push(match);
      });
      
      // 苦手マップを検出
      const weakMaps = detectWeaknesses(mapStats);
      
      const sortedMaps = sortByState(Object.keys(mapStats), mapStats, currentPerspective, sortState.map);
      
      let html = '';
      
      // 苦手マップを表示
      html += generateWeaknessHTML(weakMaps, 'マップ', '🗺️');
      
      // 並び替えボタン
      html += generateSortButtons('map');
      
      html += `<div class="stats-card">
        <div class="stats-title">マップ別勝率</div>
        <div class="bar-chart-horizontal">`;
      
      sortedMaps.forEach(map => {
        const stats = calculateWinrate(mapStats[map], currentPerspective);
        const winrateNum = parseFloat(stats.winrate) || 0;
        const barWidth = winrateNum;
        const isZero = winrateNum === 0;
        
        html += `
          <div class="bar-row">
            <div class="bar-label-wrapper">
              <div class="bar-label">${map}</div>
              <div class="bar-sublabel">${stats.wins}勝${stats.losses}敗${stats.draws}分<br>${stats.totalWithDraws}試合</div>
            </div>
            <div class="bar-wrapper">
              ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
              <div class="bar-visual" style="width: ${barWidth}%;">
                <div class="bar-value">${stats.winrate}%</div>
              </div>`}
            </div>
          </div>
        `;
      });
      
      html += '</div></div>';
      container.innerHTML = html;
    }
    
    // 対戦相手別勝率を更新
    function updateOpponentStats() {
      const container = document.getElementById('opponent-stats');
      const periodFilter = document.getElementById('opponent-period-filter').value;
      const rankFilter = document.getElementById('opponent-rank-filter').value;
      const myCharFilter = document.getElementById('my-char-filter').value;
      const opponentHunterFilter = document.getElementById('opponent-hunter-filter') ? document.getElementById('opponent-hunter-filter').value : 'all';
      const mapFilter = document.getElementById('opponent-map-filter').value;
      let perspectiveMatches = getFilteredMatches(rankFilter);
      
      // 期間でフィルター
      perspectiveMatches = filterByPeriod(perspectiveMatches, periodFilter);
      
      // 自キャラでフィルター
      if (myCharFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => m.myCharacter === myCharFilter);
      }
      
      // 対戦相手ハンターでフィルター（サバイバー視点のみ）
      if (currentPerspective === 'survivor' && opponentHunterFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => m.opponentHunter === opponentHunterFilter);
      }
      
      // マップでフィルター
      if (mapFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => m.map === mapFilter);
      }
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        return;
      }
      
      if (currentPerspective === 'survivor') {
        const hunterStats = {};
        const teammateStats = {};
        
        perspectiveMatches.forEach(match => {
          const hunter = match.opponentHunter;
          if (!hunterStats[hunter]) {
            hunterStats[hunter] = [];
          }
          hunterStats[hunter].push(match);
          
          match.teammates.forEach(teammate => {
            if (!teammateStats[teammate]) {
              teammateStats[teammate] = [];
            }
            teammateStats[teammate].push(match);
          });
        });
        
        // 苦手要素を検出
        const weakHunters = detectWeaknesses(hunterStats);
        const weakTeammates = detectWeaknesses(teammateStats);
        
        let html = '';
        
        // 苦手ハンターを表示
        html += generateWeaknessHTML(weakHunters, '対戦相手（ハンター）', '👻');
        
        // 苦手味方を表示
        html += generateWeaknessHTML(weakTeammates, '味方キャラクター', '👥');
        
        // 並び替えボタン（対戦相手ハンター用）
        html += generateSortButtons('opponentHunter');
        
        // 対戦相手ハンター別勝率
        html += `<div class="stats-card">
          <div class="stats-title">対戦相手ハンター別勝率</div>
          <div class="bar-chart-horizontal">`;
        
        const sortedHunters = sortByState(Object.keys(hunterStats), hunterStats, currentPerspective, sortState.opponentHunter);
        
        const totalHunters = sortedHunters.length;
        const totalHunterPages = Math.ceil(totalHunters / itemsPerPage);
        const hunterStartIndex = (currentPages.opponentStats - 1) * itemsPerPage;
        const hunterEndIndex = Math.min(hunterStartIndex + itemsPerPage, totalHunters);
        
        sortedHunters.slice(hunterStartIndex, hunterEndIndex).forEach(hunter => {
          const stats = calculateWinrate(hunterStats[hunter], currentPerspective);
          const winrateNum = parseFloat(stats.winrate) || 0;
          const barWidth = winrateNum;
          const isZero = winrateNum === 0;
          
          html += `
            <div class="bar-row">
              <div class="bar-label-wrapper">
                <div class="bar-label">${hunter}</div>
                <div class="bar-sublabel">${stats.wins}勝${stats.losses}敗${stats.draws}分<br>${stats.totalWithDraws}試合</div>
              </div>
              <div class="bar-wrapper">
                ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
                <div class="bar-visual" style="width: ${barWidth}%;">
                  <div class="bar-value">${stats.winrate}%</div>
                </div>`}
              </div>
            </div>
          `;
        });
        
        html += '</div>';
        html += generatePagination(currentPages.opponentStats, totalHunterPages, 'changeOpponentPage');
        html += '</div>';
        
        // 味方編成別勝率
        html += generateSortButtons('teammate');
        html += `<div class="stats-card">
          <div class="stats-title">味方編成別勝率</div>
          <div class="bar-chart-horizontal">`;
        
        const sortedTeammates = sortByState(Object.keys(teammateStats), teammateStats, currentPerspective, sortState.teammate);
        
        const totalTeammates = sortedTeammates.length;
        const totalTeammatePages = Math.ceil(totalTeammates / itemsPerPage);
        const teammateStartIndex = (currentPages.teammateStats - 1) * itemsPerPage;
        const teammateEndIndex = Math.min(teammateStartIndex + itemsPerPage, totalTeammates);
        
        sortedTeammates.slice(teammateStartIndex, teammateEndIndex).forEach(teammate => {
          const stats = calculateWinrate(teammateStats[teammate], currentPerspective);
          const winrateNum = parseFloat(stats.winrate) || 0;
          const barWidth = winrateNum;
          const isZero = winrateNum === 0;
          
          html += `
            <div class="bar-row">
              <div class="bar-label-wrapper">
                <div class="bar-label">${teammate}</div>
                <div class="bar-sublabel">${stats.wins}勝${stats.losses}敗${stats.draws}分<br>${stats.totalWithDraws}試合</div>
              </div>
              <div class="bar-wrapper">
                ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
                <div class="bar-visual" style="width: ${barWidth}%;">
                  <div class="bar-value">${stats.winrate}%</div>
                </div>`}
              </div>
            </div>
          `;
        });
        
        html += '</div>';
        html += generatePagination(currentPages.teammateStats, totalTeammatePages, 'changeTeammatePage');
        html += '</div>';
        container.innerHTML = html;
        
      } else {
        const survivorStats = {};
        
        perspectiveMatches.forEach(match => {
          match.opponentSurvivors.forEach(survivor => {
            if (!survivorStats[survivor]) {
              survivorStats[survivor] = [];
            }
            survivorStats[survivor].push(match);
          });
        });
        
        // 苦手サバイバーを検出
        const weakSurvivors = detectWeaknesses(survivorStats);
        
        let html = '';
        
        // 苦手サバイバーを表示
        html += generateWeaknessHTML(weakSurvivors, '対戦相手（サバイバー）', '👤');
        
        // 並び替えボタン
        html += generateSortButtons('opponent');
        
        html += `<div class="stats-card">
          <div class="stats-title">対戦相手サバイバー別勝率</div>
          <div class="bar-chart-horizontal">`;
        
        const sortedSurvivors = sortByState(Object.keys(survivorStats), survivorStats, currentPerspective, sortState.opponent);
        
        const totalSurvivors = sortedSurvivors.length;
        const totalPages = Math.ceil(totalSurvivors / itemsPerPage);
        const startIndex = (currentPages.opponentStats - 1) * itemsPerPage;
        const endIndex = Math.min(startIndex + itemsPerPage, totalSurvivors);
        
        sortedSurvivors.slice(startIndex, endIndex).forEach(survivor => {
          const stats = calculateWinrate(survivorStats[survivor], currentPerspective);
          const winrateNum = parseFloat(stats.winrate) || 0;
          const barWidth = winrateNum;
          const isZero = winrateNum === 0;
          
          html += `
            <div class="bar-row">
              <div class="bar-label-wrapper">
                <div class="bar-label">${survivor}</div>
                <div class="bar-sublabel">${stats.wins}勝${stats.losses}敗${stats.draws}分<br>${stats.totalWithDraws}試合</div>
              </div>
              <div class="bar-wrapper">
                ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
                <div class="bar-visual" style="width: ${barWidth}%;">
                  <div class="bar-value">${stats.winrate}%</div>
                </div>`}
              </div>
            </div>
          `;
        });
        
        html += '</div>';
        html += generatePagination(currentPages.opponentStats, totalPages, 'changeOpponentPage');
        html += '</div>';
        container.innerHTML = html;
      }
    }
    
    // 試合履歴を更新
    function updateMatchHistory() {
      const container = document.getElementById('match-history');
      const periodFilter = document.getElementById('history-period-filter').value;
      const rankFilter = document.getElementById('history-rank-filter').value;
      const opponentFilter = document.getElementById('history-opponent-filter').value;
      let perspectiveMatches = getFilteredMatches(rankFilter);
      
      // 期間でフィルター
      perspectiveMatches = filterByPeriod(perspectiveMatches, periodFilter);
      
      // 相手キャラでフィルター
      if (opponentFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => {
          if (m.perspective === 'survivor') {
            return m.opponentHunter === opponentFilter;
          } else {
            return m.opponentSurvivors && m.opponentSurvivors.includes(opponentFilter);
          }
        });
      }
      
      perspectiveMatches = perspectiveMatches.reverse();
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        return;
      }
      
      const totalMatches = perspectiveMatches.length;
      const totalPages = Math.ceil(totalMatches / itemsPerPage);
      const startIndex = (currentPages.matchHistory - 1) * itemsPerPage;
      const endIndex = Math.min(startIndex + itemsPerPage, totalMatches);
      
      let html = '<div class="match-history">';
      
      perspectiveMatches.slice(startIndex, endIndex).forEach(match => {
        const isWin = (currentPerspective === 'survivor' && match.result === 'survivor_win') || 
                      (currentPerspective === 'hunter' && match.result === 'hunter_win');
        const isDraw = match.result === 'draw';
        const resultText = isWin ? '勝利' : isDraw ? '引き分け' : '敗北';
        const displayResultClass = isWin ? 'win' : isDraw ? 'draw' : 'lose';
        const escapeInfo = match.escapeCount !== undefined ? ` (脱出${match.escapeCount}人)` : '';
        const rankInfo = match.rank ? `[${match.rank}] ` : '';
        
        let details = '';
        if (match.perspective === 'survivor') {
          details = `${rankInfo}${match.myCharacter} + ${match.teammates.join(', ')} vs ${match.opponentHunter} @ ${match.map}${escapeInfo}`;
        } else {
          details = `${rankInfo}${match.myCharacter} vs ${match.opponentSurvivors.join(', ')} @ ${match.map}${escapeInfo}`;
        }
        
        html += `
          <div class="match-item">
            <div class="match-info">
              <span class="match-result ${displayResultClass}">${resultText}</span>
              <span>${details}</span>
            </div>
            <div class="match-actions">
              <button type="button" class="edit-button" onclick="event.stopPropagation(); editMatch(${match.id}); return false;">編集</button>
              <button type="button" class="delete-button" onclick="event.stopPropagation(); deleteMatch(${match.id}); return false;">削除</button>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      html += generatePagination(currentPages.matchHistory, totalPages, 'changeHistoryPage');
      container.innerHTML = html;
    }
    
    // 試合を編集
    function editMatch(id) {
      console.log('editMatch called with id:', id);
      
      const match = matches.find(m => m.id === id);
      if (!match) {
        console.error('Match not found:', id);
        return;
      }
      
      console.log('Match found:', match);
      editingMatchId = id;
      
      if (match.perspective === 'survivor') {
        currentPerspective = 'survivor';
        document.getElementById('survivor-date').value = match.date || getToday();
        document.getElementById('survivor-rank').value = match.rank || '';
        document.getElementById('my-survivor').value = match.myCharacter;
        document.getElementById('teammate-1').value = match.teammates[0];
        document.getElementById('teammate-2').value = match.teammates[1];
        document.getElementById('teammate-3').value = match.teammates[2];
        document.getElementById('opponent-hunter').value = match.opponentHunter;
        document.getElementById('survivor-map').value = match.map;
        selectedEscapeCount.survivor = match.escapeCount !== undefined ? match.escapeCount : null;
        
        document.querySelectorAll('.perspective-tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.perspective-tab')[0].classList.add('active');
        document.getElementById('survivor-input').style.display = 'block';
        document.getElementById('hunter-input').style.display = 'none';
        
        updateSurvivorSelects(); // 選択肢を更新
        
        document.querySelectorAll('#survivor-input .result-button').forEach((btn, index) => {
          btn.classList.remove('selected');
          if (match.escapeCount !== undefined && index === match.escapeCount) {
            btn.classList.add('selected');
          }
        });
        
        // 選択肢を更新
        updateSurvivorSelectOptions();
        // SearchableSelect同期
        ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3', 'opponent-hunter'].forEach(syncSearchableSelect);
      } else {
        currentPerspective = 'hunter';
        document.getElementById('hunter-date').value = match.date || getToday();
        document.getElementById('hunter-rank').value = match.rank || '';
        document.getElementById('my-hunter').value = match.myCharacter;
        document.getElementById('opponent-survivor-1').value = match.opponentSurvivors[0];
        document.getElementById('opponent-survivor-2').value = match.opponentSurvivors[1];
        document.getElementById('opponent-survivor-3').value = match.opponentSurvivors[2];
        document.getElementById('opponent-survivor-4').value = match.opponentSurvivors[3];
        document.getElementById('hunter-map').value = match.map;
        selectedEscapeCount.hunter = match.escapeCount !== undefined ? match.escapeCount : null;
        
        document.querySelectorAll('.perspective-tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.perspective-tab')[1].classList.add('active');
        document.getElementById('survivor-input').style.display = 'none';
        document.getElementById('hunter-input').style.display = 'block';
        
        updateHunterOpponentSelectOptions(); // 選択肢を更新
        
        document.querySelectorAll('#hunter-input .result-button').forEach((btn, index) => {
          btn.classList.remove('selected');
          if (match.escapeCount !== undefined && index === match.escapeCount) {
            btn.classList.add('selected');
          }
        });
        // SearchableSelect同期
        ['my-hunter', 'opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'].forEach(syncSearchableSelect);
      }
      
      document.querySelectorAll('.main-tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.main-tab')[0].classList.add('active');
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      document.getElementById('input-tab').classList.add('active');
      
      window.scrollTo(0, 0);
    }
    
    // 試合を削除（確認なし）
    function deleteMatch(id) {
      console.log('deleteMatch called with id:', id);
      
      // 削除前に使用回数を減らす
      const match = matches.find(m => m.id === id);
      if (match) {
        if (match.perspective === 'survivor') {
          // サバイバー視点：自分、味方3人の使用回数を減らす
          decrementCharacterUsage('survivor', [match.myCharacter, ...match.teammates]);
          // 対戦相手ハンターの使用回数を減らす
          decrementCharacterUsage('hunter', match.opponentHunter);
        } else {
          // ハンター視点：自分の使用回数を減らす
          decrementCharacterUsage('hunter', match.myCharacter);
          // 対戦相手サバイバー4人の使用回数を減らす
          decrementCharacterUsage('survivor', match.opponentSurvivors);
        }
      }
      
      matches = matches.filter(m => m.id !== id);
      saveData();
      
      // 対戦相手ハンターフィルターを更新
      updateOpponentHunterFilter();
      updateHistoryOpponentFilter();
      
      // 自キャラ別勝率のマップフィルターを更新
      updateCharacterMapFilter();
      
      // セレクトボックスを再構築（使用回数順に更新）
      repopulateCharacterSelects();
      
      updateAllWithFilters();
      
      console.log('Match deleted successfully');
    }
    
    // 全データをリセット（確認ダイアログあり）
    function resetAllData() {
      console.log('resetAllData called');
      
      // 第一確認
      const firstConfirm = confirm('本当に全てのデータをリセットしますか？\nこの操作は取り消せません。');
      if (!firstConfirm) {
        console.log('User cancelled at first confirmation');
        return;
      }
      
      // 第二確認（念押し）
      const secondConfirm = confirm('最終確認：全データを削除します。\n本当によろしいですか？');
      if (!secondConfirm) {
        console.log('User cancelled at second confirmation');
        return;
      }
      
      matches = [];
      saveData();
      
      // キャラクター使用回数もリセット
      characterUsageCount = { survivor: {}, hunter: {} };
      saveCharacterUsageCount();
      
      // 対戦相手ハンターフィルターを更新
      updateOpponentHunterFilter();
      updateHistoryOpponentFilter();
      
      // 自キャラ別勝率のマップフィルターを更新
      updateCharacterMapFilter();
      
      // セレクトボックスを再構築（使用回数順に更新）
      repopulateCharacterSelects();
      
      updateAllWithFilters();
      
      console.log('All data reset successfully');
    }
    
    // データのエクスポート/インポート機能
    
    // 現在のデータ情報を更新
    function updateDataInfo() {
      const dataInfo = document.getElementById('data-info');
      if (!dataInfo) return;
      
      const survivorMatches = matches.filter(m => m.perspective === 'survivor').length;
      const hunterMatches = matches.filter(m => m.perspective === 'hunter').length;
      const totalMatches = matches.length;
      
      const survivorCharsCount = Object.keys(characterUsageCount.survivorUsed || {}).length;
      const hunterCharsCount = Object.keys(characterUsageCount.hunterUsed || {}).length;
      
      dataInfo.innerHTML = `
        <div><strong>総試合数:</strong> ${totalMatches}試合</div>
        <div style="margin-left: 20px;">└ サバイバー視点: ${survivorMatches}試合</div>
        <div style="margin-left: 20px;">└ ハンター視点: ${hunterMatches}試合</div>
        <div style="margin-top: 10px;"><strong>使用キャラクター数:</strong></div>
        <div style="margin-left: 20px;">└ サバイバー: ${survivorCharsCount}種類</div>
        <div style="margin-left: 20px;">└ ハンター: ${hunterCharsCount}種類</div>
      `;
    }
    
    // バックアップデータを作成
    function createBackupData() {
      return {
        version: '1.0.0',
        exportDate: new Date().toISOString(),
        matches: matches,
        characterUsageCount: characterUsageCount
      };
    }
    
    // クリップボードにエクスポート
    async function exportToClipboard() {
      try {
        const data = createBackupData();
        const jsonString = JSON.stringify(data, null, 2);
        
        await navigator.clipboard.writeText(jsonString);
        alert('データをクリップボードにコピーしました！\n\nLINEやメモ帳に貼り付けて保存してください。');
      } catch (error) {
        console.error('Export to clipboard failed:', error);
        alert('クリップボードへのコピーに失敗しました。\n\nファイルダウンロードをお試しください。');
      }
    }
    
    // ファイルとしてエクスポート
    function exportToFile() {
      try {
        const data = createBackupData();
        const jsonString = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        a.download = `identity5_backup_${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        alert('バックアップファイルをダウンロードしました！');
      } catch (error) {
        console.error('Export to file failed:', error);
        alert('ファイルのダウンロードに失敗しました。');
      }
    }
    
    // データを検証
    function validateBackupData(data) {
      if (!data || typeof data !== 'object') {
        return { valid: false, error: 'データ形式が正しくありません' };
      }
      
      if (!data.matches || !Array.isArray(data.matches)) {
        return { valid: false, error: '試合データが見つかりません' };
      }
      
      if (!data.characterUsageCount || typeof data.characterUsageCount !== 'object') {
        return { valid: false, error: 'キャラクター使用回数データが見つかりません' };
      }
      
      return { valid: true };
    }
    
    // データをインポート
    function importData(data) {
      const validation = validateBackupData(data);
      if (!validation.valid) {
        alert(`データの復元に失敗しました\n\n${validation.error}`);
        return false;
      }
      
      const currentMatchCount = matches.length;
      const newMatchCount = data.matches.length;
      
      const confirmed = confirm(
        `データを復元しますか？\n\n` +
        `現在のデータ: ${currentMatchCount}試合\n` +
        `復元するデータ: ${newMatchCount}試合\n\n` +
        `現在のデータは完全に上書きされます。\n` +
        `本当によろしいですか？`
      );
      
      if (!confirmed) {
        return false;
      }
      
      try {
        // データを復元
        matches = data.matches;
        characterUsageCount = data.characterUsageCount || { survivor: {}, hunter: {} };
        
        // localStorageに保存
        saveData();
        saveCharacterUsageCount();
        
        // UIを更新
        updateDataInfo();
        repopulateCharacterSelects();
        updateOpponentHunterFilter();
      updateHistoryOpponentFilter();
        updateCharacterMapFilter();
        updateAllWithFilters();
        
        alert(`データを復元しました！\n\n${newMatchCount}試合のデータを読み込みました。`);
        return true;
      } catch (error) {
        console.error('Import failed:', error);
        alert(`データの復元中にエラーが発生しました\n\n${error.message}`);
        return false;
      }
    }
    
    // テキストからインポート
    function importFromText() {
      const textarea = document.getElementById('import-textarea');
      const text = textarea.value.trim();
      
      if (!text) {
        alert('バックアップデータを貼り付けてください');
        return;
      }
      
      try {
        const data = JSON.parse(text);
        if (importData(data)) {
          textarea.value = '';
        }
      } catch (error) {
        console.error('JSON parse error:', error);
        alert('データ形式が正しくありません\n\n正しいバックアップデータを貼り付けてください。');
      }
    }
    
    // ファイルからインポート
    function importFromFile(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          importData(data);
        } catch (error) {
          console.error('JSON parse error:', error);
          alert('ファイルの読み込みに失敗しました\n\nファイル形式が正しくありません。');
        }
        
        // ファイル選択をリセット
        event.target.value = '';
      };
      
      reader.onerror = function() {
        alert('ファイルの読み込みに失敗しました');
        event.target.value = '';
      };
      
      reader.readAsText(file);
    }
    
    // ===== ダークモード =====
    function toggleDarkMode() {
      const isOn = document.getElementById('dark-mode-switch').checked;
      document.body.classList.toggle('dark-mode', isOn);
      localStorage.setItem('identity5_dark_mode', isOn ? 'on' : 'off');
      // グラフの色を更新
      updateOverallStatsTab();
    }
    
    function loadDarkMode() {
      const saved = localStorage.getItem('identity5_dark_mode');
      if (saved === 'on') {
        document.body.classList.add('dark-mode');
        const sw = document.getElementById('dark-mode-switch');
        if (sw) sw.checked = true;
      }
    }
    
    // ダークモードはDOM準備前に即時適用（ちらつき防止）
    (function() {
      if (localStorage.getItem('identity5_dark_mode') === 'on') {
        document.body.classList.add('dark-mode');
      }
    })();
    
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
