<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第五人格トラッカー | 戦績管理・勝率計算アプリ</title>
  <meta name="description" content="第五人格（Identity V）のランク戦の戦績を簡単に記録・管理できる無料ツール。勝率、キャラ別統計、マップ別データを自動計算。サバイバー/ハンター両対応で完全無料。">
  <meta name="keywords" content="第五人格,Identity V,戦績,勝率,トラッカー,ランク戦,統計,サバイバー,ハンター">

  <!-- OGP（SNS共有用） -->
  <meta property="og:title" content="第五人格トラッカー | 戦績管理・勝率計算">
  <meta property="og:description" content="第五人格のランク戦戦績を簡単に記録・管理">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://idv-tracker.github.io/">
  
  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="第五人格トラッカー">
  <meta name="twitter:description" content="戦績管理・勝率計算アプリ">
  
  <!-- アイコン設定 -->
  <link rel="apple-touch-icon" href="icon.png">
  <link rel="icon" type="image/png" sizes="180x180" href="icon.png">
  <link rel="shortcut icon" href="icon.png">
  
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6919699894432312"
     crossorigin="anonymous"></script>
  
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-EL23B3L2TD"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-EL23B3L2TD');
  </script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      overflow: hidden;
    }
    
    .header {
      background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
      color: white;
      padding: 25px;
      text-align: center;
    }
    
    .header h1 {
      font-size: 32px;
      margin-bottom: 5px;
      font-weight: 700;
    }
    
    .header .subtitle {
      font-size: 14px;
      opacity: 0.9;
      font-weight: 400;
    }
    
    .perspective-tabs {
      display: flex;
      background: #f8f9fa;
      border-bottom: 2px solid #e0e0e0;
    }
    
    .perspective-tab {
      flex: 1;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      background: #f8f9fa;
      border: none;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .perspective-tab.active {
      background: white;
      color: #0f3460;
      border-bottom: 3px solid #0f3460;
    }
    
    .perspective-tab:hover {
      background: #e9ecef;
    }
    
    .main-tabs {
      display: flex;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      overflow-x: auto;
    }
    
    .main-tab {
      padding: 12px 20px;
      cursor: pointer;
      background: #f8f9fa;
      border: none;
      font-size: 14px;
      white-space: nowrap;
      transition: all 0.3s;
    }
    
    .main-tab.active {
      background: white;
      color: #0f3460;
      border-bottom: 2px solid #0f3460;
    }
    
    .main-tab:hover {
      background: #e9ecef;
    }
    
    .content {
      padding: 25px;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    .form-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #333;
    }
    
    select {
      width: 100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      background: white;
    }
    
    select:focus {
      outline: none;
      border-color: #0f3460;
    }
    
    .result-buttons {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    
    .result-button {
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .result-button:hover {
      border-color: #0f3460;
      background: #e6f0ff;
    }
    
    .result-button.selected {
      background: #0f3460;
      color: white;
      border-color: #0f3460;
    }
    
    .submit-button {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #0f3460 0%, #533483 100%);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 20px;
      transition: transform 0.2s;
    }
    
    .submit-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(15, 52, 96, 0.4);
    }
    
    .submit-button:active {
      transform: translateY(0);
    }
    
    .filter-section {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .filter-group {
      flex: 1;
      min-width: 200px;
    }
    
    .filter-label {
      display: block;
      margin-bottom: 5px;
      font-size: 14px;
      font-weight: 600;
      color: #333;
    }
    
    .stats-card {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    
    .stats-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      color: #333;
    }
    
    .overall-stats-display {
      background: white;
      padding: 30px;
      border-radius: 8px;
      text-align: center;
    }
    
    .winrate-big {
      font-size: 48px;
      font-weight: 700;
      color: #0f3460;
      margin-bottom: 10px;
    }
    
    .record-text {
      font-size: 18px;
      color: #666;
      margin-bottom: 10px;
    }
    
    .streak-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 16px;
      font-weight: 600;
      margin-top: 10px;
    }
    
    .streak-icon {
      font-size: 20px;
    }
    
    /* 横棒グラフスタイル */
    .bar-chart-horizontal {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 20px;
      background: white;
      border-radius: 8px;
    }
    
    .bar-row {
      display: flex;
      align-items: center;
      gap: 12px;
      width: 100%;
      min-height: 45px;
    }
    
    .bar-label-wrapper {
      min-width: 110px;
      max-width: 110px;
      flex-shrink: 0;
    }
    
    .bar-label {
      font-size: 13px;
      font-weight: 600;
      color: #333;
      word-wrap: break-word;
      margin-bottom: 3px;
    }
    
    .bar-sublabel {
      font-size: 10px;
      color: #999;
      line-height: 1.3;
    }
    
    .bar-wrapper {
      flex: 1;
      min-width: 0;
      height: 28px;
      background: #f0f0f0;
      border-radius: 4px;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
    }
    
    .bar-visual {
      height: 100%;
      background: linear-gradient(90deg, #60a5fa, #3b82f6);
      border-radius: 4px;
      transition: width 0.3s ease;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 10px;
    }
    
    .bar-value {
      color: white;
      font-size: 11px;
      font-weight: 700;
      white-space: nowrap;
    }
    
    .bar-value-zero {
      position: static;
      transform: none;
      color: #999;
      background: transparent;
      font-size: 11px;
      font-weight: 600;
      padding-left: 10px;
    }
    
    .match-history {
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      overflow: hidden;
    }
    
    .match-item {
      padding: 15px;
      border-bottom: 1px solid #dee2e6;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .match-item:last-child {
      border-bottom: none;
    }
    
    .match-info {
      flex: 1;
    }
    
    .match-result {
      padding: 5px 12px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
      margin-right: 10px;
    }
    
    .match-result.win {
      background: #d4edda;
      color: #155724;
    }
    
    .match-result.lose {
      background: #f8d7da;
      color: #721c24;
    }
    
    .match-result.draw {
      background: #fff3cd;
      color: #856404;
    }
    
    .match-actions button {
      margin-left: 5px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .edit-button {
      background: #ffc107;
      color: #000;
    }
    
    .delete-button {
      background: #dc3545;
      color: white;
    }
    
    .reset-button {
      background: #dc3545;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 20px;
    }
    
    .reset-button:hover {
      background: #c82333;
    }
    
    .empty-state {
      text-align: center;
      padding: 40px;
      color: #999;
    }
    
    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>第五人格トラッカー</h1>
      <div class="subtitle">戦績管理・勝率計算</div>
    </div>
    
    <div class="perspective-tabs">
      <button class="perspective-tab active" onclick="switchPerspective('survivor')">サバイバー</button>
      <button class="perspective-tab" onclick="switchPerspective('hunter')">ハンター</button>
    </div>
    
    <div class="main-tabs">
      <button class="main-tab active" onclick="switchTab('input')">試合入力</button>
      <button class="main-tab" onclick="switchTab('character')">自キャラ別勝率</button>
      <button class="main-tab" onclick="switchTab('map')">マップ別勝率</button>
      <button class="main-tab" onclick="switchTab('opponent')">対戦相手別勝率</button>
      <button class="main-tab" onclick="switchTab('history')">試合履歴</button>
    </div>
    
    <div class="content">
      <!-- 試合入力タブ -->
      <div id="input-tab" class="tab-content active">
        <div id="overall-stats-inline"></div>
        
        <div id="survivor-input">
          <button type="button" onclick="event.preventDefault(); event.stopPropagation(); clearAllPersistence('survivor'); return false;" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 6px; font-size: 13px; cursor: pointer; margin-bottom: 15px;">全てクリア</button>
          
          <div class="form-group">
            <label class="form-label">段位 <input type="checkbox" id="persist-survivor-rank" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="survivor-rank">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">自分のサバイバー <input type="checkbox" id="persist-my-survivor" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="my-survivor" onchange="updateSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">味方サバイバー1 <input type="checkbox" id="persist-teammate-1" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="teammate-1" onchange="updateSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">味方サバイバー2 <input type="checkbox" id="persist-teammate-2" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="teammate-2" onchange="updateSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">味方サバイバー3 <input type="checkbox" id="persist-teammate-3" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="teammate-3" onchange="updateSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">相手ハンター <input type="checkbox" id="persist-opponent-hunter" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="opponent-hunter">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">マップ <input type="checkbox" id="persist-survivor-map" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="survivor-map">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">脱出人数</label>
            <div class="result-buttons">
              <button class="result-button" onclick="selectEscapeCount('survivor', 0)">0人</button>
              <button class="result-button" onclick="selectEscapeCount('survivor', 1)">1人</button>
              <button class="result-button" onclick="selectEscapeCount('survivor', 2)">2人</button>
              <button class="result-button" onclick="selectEscapeCount('survivor', 3)">3人</button>
              <button class="result-button" onclick="selectEscapeCount('survivor', 4)">4人</button>
            </div>
          </div>
          
          <button type="button" class="submit-button" onclick="submitMatch('survivor')">試合を記録</button>
        </div>
        
        <div id="hunter-input" style="display: none;">
          <button type="button" onclick="event.preventDefault(); event.stopPropagation(); clearAllPersistence('hunter'); return false;" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 6px; font-size: 13px; cursor: pointer; margin-bottom: 15px;">全てクリア</button>
          
          <div class="form-group">
            <label class="form-label">段位 <input type="checkbox" id="persist-hunter-rank" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="hunter-rank">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">自分のハンター <input type="checkbox" id="persist-my-hunter" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="my-hunter">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">相手サバイバー1 <input type="checkbox" id="persist-opponent-survivor-1" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="opponent-survivor-1" onchange="updateOpponentSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">相手サバイバー2 <input type="checkbox" id="persist-opponent-survivor-2" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="opponent-survivor-2" onchange="updateOpponentSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">相手サバイバー3 <input type="checkbox" id="persist-opponent-survivor-3" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="opponent-survivor-3" onchange="updateOpponentSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">相手サバイバー4 <input type="checkbox" id="persist-opponent-survivor-4" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="opponent-survivor-4" onchange="updateOpponentSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">マップ <input type="checkbox" id="persist-hunter-map" style="margin-left: 8px;"> <span style="font-size: 12px;">保持</span></label>
            <select id="hunter-map">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">脱出人数</label>
            <div class="result-buttons">
              <button class="result-button" onclick="selectEscapeCount('hunter', 0)">0人</button>
              <button class="result-button" onclick="selectEscapeCount('hunter', 1)">1人</button>
              <button class="result-button" onclick="selectEscapeCount('hunter', 2)">2人</button>
              <button class="result-button" onclick="selectEscapeCount('hunter', 3)">3人</button>
              <button class="result-button" onclick="selectEscapeCount('hunter', 4)">4人</button>
            </div>
          </div>
          
          <button class="submit-button" onclick="submitMatch('hunter')">試合を記録</button>
        </div>
      </div>
      
      <!-- 自キャラ別勝率タブ -->
      <div id="character-tab" class="tab-content">
        <div class="filter-section">
          <div class="filter-group">
            <label class="filter-label">段位フィルター</label>
            <select id="character-rank-filter" onchange="updateAllStats()">
              <option value="all">全段位</option>
            </select>
          </div>
        </div>
        <div id="character-stats"></div>
      </div>
      
      <!-- マップ別勝率タブ -->
      <div id="map-tab" class="tab-content">
        <div class="filter-section">
          <div class="filter-group">
            <label class="filter-label">段位フィルター</label>
            <select id="map-rank-filter" onchange="updateAllStats()">
              <option value="all">全段位</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">自キャラフィルター</label>
            <select id="map-char-filter" onchange="updateAllStats()">
              <option value="all">全キャラ</option>
            </select>
          </div>
        </div>
        <div id="map-stats"></div>
      </div>
      
      <!-- 対戦相手別勝率タブ -->
      <div id="opponent-tab" class="tab-content">
        <div class="filter-section">
          <div class="filter-group">
            <label class="filter-label">段位フィルター</label>
            <select id="opponent-rank-filter" onchange="updateAllStats()">
              <option value="all">全段位</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">自キャラフィルター</label>
            <select id="my-char-filter" onchange="onMyCharFilterChange()">
              <option value="all">全キャラ</option>
            </select>
          </div>
          <div class="filter-group" id="opponent-filter-group">
            <label class="filter-label">対戦相手フィルター</label>
            <select id="opponent-hunter-filter" onchange="updateAllStats()">
              <option value="all">全て</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">マップフィルター</label>
            <select id="opponent-map-filter" onchange="updateAllStats()">
              <option value="all">全マップ</option>
            </select>
          </div>
        </div>
        <div id="opponent-stats"></div>
      </div>
      
      <!-- 試合履歴タブ -->
      <div id="history-tab" class="tab-content">
        <div class="filter-section">
          <div class="filter-group">
            <label class="filter-label">段位フィルター</label>
            <select id="history-rank-filter" onchange="updateAllStats()">
              <option value="all">全段位</option>
            </select>
          </div>
        </div>
        <div id="match-history"></div>
        <button type="button" class="reset-button" onclick="event.stopPropagation(); resetAllData(); return false;">全データをリセット</button>
      </div>
    </div>
    
    <!-- プライバシーポリシーリンク -->
    <div style="text-align: center; padding: 30px 20px 20px 20px;">
      <a href="privacy.html" style="color: #94a3b8; text-decoration: none; font-size: 13px; transition: color 0.2s;" onmouseover="this.style.color='#cbd5e1'" onmouseout="this.style.color='#94a3b8'">プライバシーポリシー</a>
    </div>
  </div>

  <script>
    const SURVIVORS = ['幸運児', '医師', '弁護士', '泥棒', '庭師', 'マジシャン', '冒険家', '傭兵', '祭司', '空軍', '機械技師', 'オフェンス', '心眼', '調香師', 'カウボーイ', '踊り子', '占い師', '納棺師', '探鉱者', '呪術師', '野人', '曲芸師', '一等航海士', 'バーメイド', 'ポストマン', '墓守', '「囚人」', '昆虫学者', '画家', 'バッツマン', '玩具職人', '患者', '「心理学者」', '小説家', '「少女」', '泣きピエロ', '教授', '骨董商', '作曲家', '記者', '航空エンジニア', '応援団', '人形師', '火災調査員', '「レディ・ファウロ」', '「騎士」', '気象学者', '弓使い', '「脱出マスター」', '幻灯師', '闘牛士'];
    
    const HUNTERS = ['復讐者', '道化師', '断罪狩人', 'リッパー', '結魂者', '芸者', '白黒無常', '写真家', '狂眼', '黄衣の王', '夢の魔女', '泣き虫', '魔トカゲ', '血の女王', 'ガードNo.26', '「使徒」', 'ヴァイオリニスト', '彫刻師', 'アンデッド', '破輪', '漁師', '蝋人形師', '「悪夢」', '書記官', '隠者', '夜の番人', 'オペラ歌手', '「フールズ・ゴールド」', '時空の影', '「足萎えの羊」', '「フラバルー」', '雑貨商', '「ビリヤードプレイヤー」', '「女王蜂」'];
    
    const MAPS = ['軍需工場', '赤の教会', '聖心病院', '湖景村', '月の河公園', 'レオの思い出', '永眠町', '中華街', '罪の森'];
    
    const RANKS = ['1段', '2段', '3段', '4段', '5段', '6段', '7段', '最高峰'];
    
    let currentPerspective = 'survivor';
    let selectedEscapeCount = { survivor: null, hunter: null };
    let matches = [];
    let editingMatchId = null;
    let overallStatsMode = 'all'; // 'all' または 'recent100'
    
    // ページネーション用の変数
    let currentPages = {
      teammateStats: 1,
      opponentStats: 1,
      matchHistory: 1
    };
    const itemsPerPage = 20;
    
    // 初期化
    function init() {
      populateSelects();
      updateSurvivorSelects(); // サバイバー選択肢の初期化
      updateOpponentSurvivorSelects(); // 相手サバイバー選択肢の初期化
      loadData(); // データを読み込む（保持値の復元は後で）
      
      // 保持された値を復元（DOM要素が完全に準備された後）
      loadPersistedValues('survivor');
      loadPersistedValues('hunter');
      
      // 初期状態はサバイバー視点なので、対戦相手フィルターを表示
      const opponentFilterGroup = document.getElementById('opponent-filter-group');
      if (opponentFilterGroup) {
        opponentFilterGroup.style.display = 'block';
      }
      
      updateAllWithFilters(); // フィルターと統計を更新
    }
    
    // サバイバー選択肢を更新（重複を除外）
    function updateSurvivorSelects() {
      const mySurvivor = document.getElementById('my-survivor').value;
      const teammate1 = document.getElementById('teammate-1').value;
      const teammate2 = document.getElementById('teammate-2').value;
      const teammate3 = document.getElementById('teammate-3').value;
      
      const selected = [mySurvivor, teammate1, teammate2, teammate3].filter(v => v);
      
      const selectIds = ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3'];
      
      selectIds.forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // 選択肢を再構築
        select.innerHTML = '<option value="">選択してください</option>';
        SURVIVORS.forEach(survivor => {
          // 自分が選択中か、他で選択されていない場合のみ表示
          if (survivor === currentValue || !selected.includes(survivor)) {
            const option = document.createElement('option');
            option.value = survivor;
            option.textContent = survivor;
            select.appendChild(option);
          }
        });
        
        // 値を復元
        select.value = currentValue;
      });
    }
    
    // ハンター視点の相手サバイバー選択肢を更新（重複を除外）
    function updateOpponentSurvivorSelects() {
      const survivor1 = document.getElementById('opponent-survivor-1').value;
      const survivor2 = document.getElementById('opponent-survivor-2').value;
      const survivor3 = document.getElementById('opponent-survivor-3').value;
      const survivor4 = document.getElementById('opponent-survivor-4').value;
      
      const selected = [survivor1, survivor2, survivor3, survivor4].filter(v => v);
      
      const selectIds = ['opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'];
      
      selectIds.forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // 選択肢を再構築
        select.innerHTML = '<option value="">選択してください</option>';
        SURVIVORS.forEach(survivor => {
          // 自分が選択中か、他で選択されていない場合のみ表示
          if (survivor === currentValue || !selected.includes(survivor)) {
            const option = document.createElement('option');
            option.value = survivor;
            option.textContent = survivor;
            select.appendChild(option);
          }
        });
        
        // 値を復元
        select.value = currentValue;
      });
    }
    
    // セレクトボックスにオプションを追加
    function populateSelects() {
      const survivorSelects = ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3', 'opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'];
      survivorSelects.forEach(id => {
        const select = document.getElementById(id);
        SURVIVORS.forEach(survivor => {
          const option = document.createElement('option');
          option.value = survivor;
          option.textContent = survivor;
          select.appendChild(option);
        });
      });
      
      const hunterSelects = ['my-hunter', 'opponent-hunter'];
      hunterSelects.forEach(id => {
        const select = document.getElementById(id);
        HUNTERS.forEach(hunter => {
          const option = document.createElement('option');
          option.value = hunter;
          option.textContent = hunter;
          select.appendChild(option);
        });
      });
      
      // 対戦相手ハンターフィルターの選択肢を追加
      const opponentHunterFilter = document.getElementById('opponent-hunter-filter');
      if (opponentHunterFilter) {
        HUNTERS.forEach(hunter => {
          const option = document.createElement('option');
          option.value = hunter;
          option.textContent = hunter;
          opponentHunterFilter.appendChild(option);
        });
      }
      
      const mapSelects = ['survivor-map', 'hunter-map'];
      mapSelects.forEach(id => {
        const select = document.getElementById(id);
        MAPS.forEach(map => {
          const option = document.createElement('option');
          option.value = map;
          option.textContent = map;
          select.appendChild(option);
        });
      });
      
      const rankSelects = ['survivor-rank', 'hunter-rank'];
      rankSelects.forEach(id => {
        const select = document.getElementById(id);
        RANKS.forEach(rank => {
          const option = document.createElement('option');
          option.value = rank;
          option.textContent = rank;
          select.appendChild(option);
        });
      });
      
      // サバイバー選択時の重複チェックを追加
      ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => updateSurvivorSelectOptions());
      });
      
      // ハンター視点のサバイバー選択時の重複チェックを追加
      ['opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => updateHunterOpponentSelectOptions());
      });
    }
    
    // サバイバー視点：選択済みキャラを他の選択肢から除外
    function updateSurvivorSelectOptions() {
      const mySurvivor = document.getElementById('my-survivor').value;
      const teammate1 = document.getElementById('teammate-1').value;
      const teammate2 = document.getElementById('teammate-2').value;
      const teammate3 = document.getElementById('teammate-3').value;
      
      const selected = [mySurvivor, teammate1, teammate2, teammate3].filter(v => v);
      
      ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3'].forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // 選択肢を再構築
        select.innerHTML = '<option value="">選択してください</option>';
        SURVIVORS.forEach(survivor => {
          // 自分以外で選択されているキャラは除外
          if (!selected.includes(survivor) || survivor === currentValue) {
            const option = document.createElement('option');
            option.value = survivor;
            option.textContent = survivor;
            select.appendChild(option);
          }
        });
        
        // 現在の値を復元
        select.value = currentValue;
      });
    }
    
    // ハンター視点：選択済みキャラを他の選択肢から除外
    function updateHunterOpponentSelectOptions() {
      const opponent1 = document.getElementById('opponent-survivor-1').value;
      const opponent2 = document.getElementById('opponent-survivor-2').value;
      const opponent3 = document.getElementById('opponent-survivor-3').value;
      const opponent4 = document.getElementById('opponent-survivor-4').value;
      
      const selected = [opponent1, opponent2, opponent3, opponent4].filter(v => v);
      
      ['opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'].forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // 選択肢を再構築
        select.innerHTML = '<option value="">選択してください</option>';
        SURVIVORS.forEach(survivor => {
          // 自分以外で選択されているキャラは除外
          if (!selected.includes(survivor) || survivor === currentValue) {
            const option = document.createElement('option');
            option.value = survivor;
            option.textContent = survivor;
            select.appendChild(option);
          }
        });
        
        // 現在の値を復元
        select.value = currentValue;
      });
    }
    
    // 段位フィルターを設定（使用済み段位のみ）
    function populateRankFilters() {
      const perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      const usedRanks = [...new Set(perspectiveMatches.map(m => m.rank).filter(r => r))];
      
      // RANKS配列の順序を保持してソート
      const sortedRanks = RANKS.filter(rank => usedRanks.includes(rank));
      
      const filterIds = ['character-rank-filter', 'map-rank-filter', 'opponent-rank-filter', 'history-rank-filter'];
      filterIds.forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        select.innerHTML = '<option value="all">全段位</option>';
        
        sortedRanks.forEach(rank => {
          const option = document.createElement('option');
          option.value = rank;
          option.textContent = rank;
          select.appendChild(option);
        });
        
        // 前回選択していた値を復元
        if (currentValue && (currentValue === 'all' || sortedRanks.includes(currentValue))) {
          select.value = currentValue;
        }
      });
      
      // マップフィルター（対戦相手別勝率用、自キャラフィルターに連動）
      const myCharFilterValue = document.getElementById('my-char-filter')?.value || 'all';
      updateMapFilter(myCharFilterValue);
      
      // 自キャラフィルター
      updateMyCharFilter();
    }
    
    // マップフィルターを更新（自キャラフィルターに連動）
    function updateMapFilter(selectedChar = 'all') {
      const perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      
      // 自キャラでフィルター
      let filteredMatches = perspectiveMatches;
      if (selectedChar !== 'all') {
        filteredMatches = perspectiveMatches.filter(m => m.myCharacter === selectedChar);
      }
      
      const usedMaps = [...new Set(filteredMatches.map(m => m.map))].sort();
      
      const mapSelect = document.getElementById('opponent-map-filter');
      const currentValue = mapSelect.value;
      mapSelect.innerHTML = '<option value="all">全マップ</option>';
      usedMaps.forEach(map => {
        const option = document.createElement('option');
        option.value = map;
        option.textContent = map;
        mapSelect.appendChild(option);
      });
      
      // 前回選択していた値を復元（存在する場合のみ）
      if (currentValue && (currentValue === 'all' || usedMaps.includes(currentValue))) {
        mapSelect.value = currentValue;
      }
    }
    
    // 自キャラフィルターを更新（使用済みキャラのみ）
    function updateMyCharFilter() {
      const perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      const usedChars = [...new Set(perspectiveMatches.map(m => m.myCharacter))].sort();
      
      // 対戦相手別勝率のフィルター
      const opponentSelect = document.getElementById('my-char-filter');
      opponentSelect.innerHTML = '<option value="all">全キャラ</option>';
      usedChars.forEach(char => {
        const option = document.createElement('option');
        option.value = char;
        option.textContent = char;
        opponentSelect.appendChild(option);
      });
      
      // マップ別勝率のフィルター
      const mapSelect = document.getElementById('map-char-filter');
      mapSelect.innerHTML = '<option value="all">全キャラ</option>';
      usedChars.forEach(char => {
        const option = document.createElement('option');
        option.value = char;
        option.textContent = char;
        mapSelect.appendChild(option);
      });
    }
    
    // 視点を切り替え
    function switchPerspective(perspective) {
      currentPerspective = perspective;
      
      document.querySelectorAll('.perspective-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');
      
      if (perspective === 'survivor') {
        document.getElementById('survivor-input').style.display = 'block';
        document.getElementById('hunter-input').style.display = 'none';
        
        // サバイバー視点では対戦相手フィルターを表示
        const opponentFilterGroup = document.getElementById('opponent-filter-group');
        if (opponentFilterGroup) {
          opponentFilterGroup.style.display = 'block';
        }
      } else {
        document.getElementById('survivor-input').style.display = 'none';
        document.getElementById('hunter-input').style.display = 'block';
        
        // ハンター視点では対戦相手フィルターを非表示
        const opponentFilterGroup = document.getElementById('opponent-filter-group');
        if (opponentFilterGroup) {
          opponentFilterGroup.style.display = 'none';
        }
      }
      
      updateAllWithFilters();
    }
    
    // タブを切り替え
    function switchTab(tabName) {
      document.querySelectorAll('.main-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');
      
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(tabName + '-tab').classList.add('active');
      
      updateAllStats();
    }
    
    // 脱出人数を選択
    function selectEscapeCount(perspective, count) {
      selectedEscapeCount[perspective] = count;
      
      const container = perspective === 'survivor' ? document.getElementById('survivor-input') : document.getElementById('hunter-input');
      container.querySelectorAll('.result-button').forEach(btn => {
        btn.classList.remove('selected');
      });
      event.target.classList.add('selected');
    }
    
    // 脱出人数から勝敗を判定
    function getResultFromEscapeCount(escapeCount, perspective) {
      if (perspective === 'survivor') {
        if (escapeCount >= 3) return 'survivor_win';
        if (escapeCount === 2) return 'draw';
        return 'hunter_win';
      } else {
        if (escapeCount <= 1) return 'hunter_win';
        if (escapeCount === 2) return 'draw';
        return 'survivor_win';
      }
    }
    
    // 試合を記録
    function submitMatch(perspective) {
      let match = {
        id: editingMatchId || Date.now(),
        perspective: perspective,
        timestamp: new Date().toISOString()
      };
      
      if (perspective === 'survivor') {
        const rank = document.getElementById('survivor-rank').value;
        const mySurvivor = document.getElementById('my-survivor').value;
        const teammate1 = document.getElementById('teammate-1').value;
        const teammate2 = document.getElementById('teammate-2').value;
        const teammate3 = document.getElementById('teammate-3').value;
        const opponentHunter = document.getElementById('opponent-hunter').value;
        const map = document.getElementById('survivor-map').value;
        const escapeCount = selectedEscapeCount.survivor;
        
        if (!rank || !mySurvivor || !teammate1 || !teammate2 || !teammate3 || !opponentHunter || !map || escapeCount === null) {
          alert('全ての項目を入力してください');
          return;
        }
        
        match.rank = rank;
        match.myCharacter = mySurvivor;
        match.teammates = [teammate1, teammate2, teammate3];
        match.opponentHunter = opponentHunter;
        match.map = map;
        match.escapeCount = escapeCount;
        match.result = getResultFromEscapeCount(escapeCount, perspective);
      } else {
        const rank = document.getElementById('hunter-rank').value;
        const myHunter = document.getElementById('my-hunter').value;
        const opponentSurvivor1 = document.getElementById('opponent-survivor-1').value;
        const opponentSurvivor2 = document.getElementById('opponent-survivor-2').value;
        const opponentSurvivor3 = document.getElementById('opponent-survivor-3').value;
        const opponentSurvivor4 = document.getElementById('opponent-survivor-4').value;
        const map = document.getElementById('hunter-map').value;
        const escapeCount = selectedEscapeCount.hunter;
        
        if (!rank || !myHunter || !opponentSurvivor1 || !opponentSurvivor2 || !opponentSurvivor3 || !opponentSurvivor4 || !map || escapeCount === null) {
          alert('全ての項目を入力してください');
          return;
        }
        
        match.rank = rank;
        match.myCharacter = myHunter;
        match.opponentSurvivors = [opponentSurvivor1, opponentSurvivor2, opponentSurvivor3, opponentSurvivor4];
        match.map = map;
        match.escapeCount = escapeCount;
        match.result = getResultFromEscapeCount(escapeCount, perspective);
      }
      
      if (editingMatchId) {
        matches = matches.filter(m => m.id !== editingMatchId);
        editingMatchId = null;
      }
      
      matches.push(match);
      saveData();
      
      // 保持設定を保存
      savePersistedValues(perspective);
      
      resetForm(perspective);
      alert('試合を記録しました！');
      updateAllWithFilters();
    }
    
    // フォームをリセット（保持設定に応じて）
    function resetForm(perspective) {
      if (perspective === 'survivor') {
        const fields = [
          { id: 'survivor-rank', persistKey: 'persist-survivor-rank' },
          { id: 'my-survivor', persistKey: 'persist-my-survivor' },
          { id: 'teammate-1', persistKey: 'persist-teammate-1' },
          { id: 'teammate-2', persistKey: 'persist-teammate-2' },
          { id: 'teammate-3', persistKey: 'persist-teammate-3' },
          { id: 'opponent-hunter', persistKey: 'persist-opponent-hunter' },
          { id: 'survivor-map', persistKey: 'persist-survivor-map' }
        ];
        
        fields.forEach(field => {
          const persistCheckbox = document.getElementById(field.persistKey);
          const select = document.getElementById(field.id);
          
          // 保持チェックボックスがオフの場合のみクリア
          if (!persistCheckbox || !persistCheckbox.checked) {
            if (select) {
              select.value = '';
            }
          }
        });
        
        selectedEscapeCount.survivor = null;
        document.querySelectorAll('#survivor-input .result-button').forEach(btn => {
          btn.classList.remove('selected');
        });
        updateSurvivorSelectOptions(); // 選択肢を更新
      } else {
        const fields = [
          { id: 'hunter-rank', persistKey: 'persist-hunter-rank' },
          { id: 'my-hunter', persistKey: 'persist-my-hunter' },
          { id: 'opponent-survivor-1', persistKey: 'persist-opponent-survivor-1' },
          { id: 'opponent-survivor-2', persistKey: 'persist-opponent-survivor-2' },
          { id: 'opponent-survivor-3', persistKey: 'persist-opponent-survivor-3' },
          { id: 'opponent-survivor-4', persistKey: 'persist-opponent-survivor-4' },
          { id: 'hunter-map', persistKey: 'persist-hunter-map' }
        ];
        
        fields.forEach(field => {
          const persistCheckbox = document.getElementById(field.persistKey);
          const select = document.getElementById(field.id);
          
          // 保持チェックボックスがオフの場合のみクリア
          if (!persistCheckbox || !persistCheckbox.checked) {
            if (select) {
              select.value = '';
            }
          }
        });
        
        selectedEscapeCount.hunter = null;
        document.querySelectorAll('#hunter-input .result-button').forEach(btn => {
          btn.classList.remove('selected');
        });
        updateHunterOpponentSelectOptions(); // 選択肢を更新
      }
    }
    
    // データを保存
    function saveData() {
      localStorage.setItem('identity5_matches', JSON.stringify(matches));
    }
    
    // データを読み込み
    function loadData() {
      const saved = localStorage.getItem('identity5_matches');
      if (saved) {
        matches = JSON.parse(saved);
      }
    }
    
    // 保持された値を復元
    function loadPersistedValues(perspective) {
      try {
        if (perspective === 'survivor') {
          const fields = [
            { id: 'survivor-rank', persistKey: 'persist-survivor-rank' },
            { id: 'my-survivor', persistKey: 'persist-my-survivor' },
            { id: 'teammate-1', persistKey: 'persist-teammate-1' },
            { id: 'teammate-2', persistKey: 'persist-teammate-2' },
            { id: 'teammate-3', persistKey: 'persist-teammate-3' },
            { id: 'opponent-hunter', persistKey: 'persist-opponent-hunter' },
            { id: 'survivor-map', persistKey: 'persist-survivor-map' }
          ];
          
          fields.forEach(field => {
            const persistCheckbox = document.getElementById(field.persistKey);
            const select = document.getElementById(field.id);
            const savedValue = localStorage.getItem(`persist_value_${field.id}`);
            const isChecked = localStorage.getItem(`persist_checkbox_${field.persistKey}`) === 'true';
            
            if (isChecked && persistCheckbox) {
              persistCheckbox.checked = true;
            }
            
            if (savedValue && select) {
              select.value = savedValue;
            }
          });
        } else {
          const fields = [
            { id: 'hunter-rank', persistKey: 'persist-hunter-rank' },
            { id: 'my-hunter', persistKey: 'persist-my-hunter' },
            { id: 'opponent-survivor-1', persistKey: 'persist-opponent-survivor-1' },
            { id: 'opponent-survivor-2', persistKey: 'persist-opponent-survivor-2' },
            { id: 'opponent-survivor-3', persistKey: 'persist-opponent-survivor-3' },
            { id: 'opponent-survivor-4', persistKey: 'persist-opponent-survivor-4' },
            { id: 'hunter-map', persistKey: 'persist-hunter-map' }
          ];
          
          fields.forEach(field => {
            const persistCheckbox = document.getElementById(field.persistKey);
            const select = document.getElementById(field.id);
            const savedValue = localStorage.getItem(`persist_value_${field.id}`);
            const isChecked = localStorage.getItem(`persist_checkbox_${field.persistKey}`) === 'true';
            
            if (isChecked && persistCheckbox) {
              persistCheckbox.checked = true;
            }
            
            if (savedValue && select) {
              select.value = savedValue;
            }
          });
        }
      } catch (error) {
        console.error('Error loading persisted values:', error);
      }
    }
    
    // 保持設定を保存
    function savePersistedValues(perspective) {
      try {
        if (perspective === 'survivor') {
          const fields = [
            { id: 'survivor-rank', persistKey: 'persist-survivor-rank' },
            { id: 'my-survivor', persistKey: 'persist-my-survivor' },
            { id: 'teammate-1', persistKey: 'persist-teammate-1' },
            { id: 'teammate-2', persistKey: 'persist-teammate-2' },
            { id: 'teammate-3', persistKey: 'persist-teammate-3' },
            { id: 'opponent-hunter', persistKey: 'persist-opponent-hunter' },
            { id: 'survivor-map', persistKey: 'persist-survivor-map' }
          ];
          
          fields.forEach(field => {
            const persistCheckbox = document.getElementById(field.persistKey);
            const select = document.getElementById(field.id);
            
            if (persistCheckbox && persistCheckbox.checked) {
              localStorage.setItem(`persist_checkbox_${field.persistKey}`, 'true');
              if (select) {
                localStorage.setItem(`persist_value_${field.id}`, select.value);
              }
            } else {
              localStorage.removeItem(`persist_checkbox_${field.persistKey}`);
              localStorage.removeItem(`persist_value_${field.id}`);
            }
          });
        } else {
          const fields = [
            { id: 'hunter-rank', persistKey: 'persist-hunter-rank' },
            { id: 'my-hunter', persistKey: 'persist-my-hunter' },
            { id: 'opponent-survivor-1', persistKey: 'persist-opponent-survivor-1' },
            { id: 'opponent-survivor-2', persistKey: 'persist-opponent-survivor-2' },
            { id: 'opponent-survivor-3', persistKey: 'persist-opponent-survivor-3' },
            { id: 'opponent-survivor-4', persistKey: 'persist-opponent-survivor-4' },
            { id: 'hunter-map', persistKey: 'persist-hunter-map' }
          ];
          
          fields.forEach(field => {
            const persistCheckbox = document.getElementById(field.persistKey);
            const select = document.getElementById(field.id);
            
            if (persistCheckbox && persistCheckbox.checked) {
              localStorage.setItem(`persist_checkbox_${field.persistKey}`, 'true');
              if (select) {
                localStorage.setItem(`persist_value_${field.id}`, select.value);
              }
            } else {
              localStorage.removeItem(`persist_checkbox_${field.persistKey}`);
              localStorage.removeItem(`persist_value_${field.id}`);
            }
          });
        }
      } catch (error) {
        console.error('Error saving persisted values:', error);
      }
    }
    
    // 全ての保持設定をクリア（確認なし）
    function clearAllPersistence(perspective) {
      console.log('clearAllPersistence called with perspective:', perspective);
      
      try {
        console.log('Clearing persistence immediately...');
        
        if (perspective === 'survivor') {
          const fields = [
            { id: 'survivor-rank', persistKey: 'persist-survivor-rank' },
            { id: 'my-survivor', persistKey: 'persist-my-survivor' },
            { id: 'teammate-1', persistKey: 'persist-teammate-1' },
            { id: 'teammate-2', persistKey: 'persist-teammate-2' },
            { id: 'teammate-3', persistKey: 'persist-teammate-3' },
            { id: 'opponent-hunter', persistKey: 'persist-opponent-hunter' },
            { id: 'survivor-map', persistKey: 'persist-survivor-map' }
          ];
          
          fields.forEach(field => {
            const persistCheckbox = document.getElementById(field.persistKey);
            const select = document.getElementById(field.id);
            
            console.log(`Processing field: ${field.id}, checkbox found: ${!!persistCheckbox}, select found: ${!!select}`);
            
            if (persistCheckbox) {
              persistCheckbox.checked = false;
            }
            
            if (select) {
              select.value = '';
            }
            
            localStorage.removeItem(`persist_checkbox_${field.persistKey}`);
            localStorage.removeItem(`persist_value_${field.id}`);
          });
          
          // 選択肢を更新
          updateSurvivorSelectOptions();
          
          console.log('Survivor persistence cleared successfully');
        } else {
          const fields = [
            { id: 'hunter-rank', persistKey: 'persist-hunter-rank' },
            { id: 'my-hunter', persistKey: 'persist-my-hunter' },
            { id: 'opponent-survivor-1', persistKey: 'persist-opponent-survivor-1' },
            { id: 'opponent-survivor-2', persistKey: 'persist-opponent-survivor-2' },
            { id: 'opponent-survivor-3', persistKey: 'persist-opponent-survivor-3' },
            { id: 'opponent-survivor-4', persistKey: 'persist-opponent-survivor-4' },
            { id: 'hunter-map', persistKey: 'persist-hunter-map' }
          ];
          
          fields.forEach(field => {
            const persistCheckbox = document.getElementById(field.persistKey);
            const select = document.getElementById(field.id);
            
            console.log(`Processing field: ${field.id}, checkbox found: ${!!persistCheckbox}, select found: ${!!select}`);
            
            if (persistCheckbox) {
              persistCheckbox.checked = false;
            }
            
            if (select) {
              select.value = '';
            }
            
            localStorage.removeItem(`persist_checkbox_${field.persistKey}`);
            localStorage.removeItem(`persist_value_${field.id}`);
          });
          
          // 選択肢を更新
          updateHunterOpponentSelectOptions();
          
          console.log('Hunter persistence cleared successfully');
        }
      } catch (error) {
        console.error('Error clearing persistence:', error);
      }
    }
    
    // 入力値を保存
    // フィルタリングされたデータを取得
    function getFilteredMatches(rankFilter) {
      let filtered = matches.filter(m => m.perspective === currentPerspective);
      if (rankFilter && rankFilter !== 'all') {
        filtered = filtered.filter(m => m.rank === rankFilter);
      }
      return filtered;
    }
    
    // 自キャラフィルター変更時の処理
    function onMyCharFilterChange() {
      const selectedChar = document.getElementById('my-char-filter').value;
      updateMapFilter(selectedChar);
      updateAllStats();
    }
    
    // 全ての統計を更新
    function updateAllStats() {
      updateOverallStats();
      updateCharacterStats();
      updateMapStats();
      updateOpponentStats();
      updateMatchHistory();
    }
    
    // フィルター変更時にページをリセット
    function resetPagination() {
      currentPages.teammateStats = 1;
      currentPages.opponentStats = 1;
      currentPages.matchHistory = 1;
    }
    
    // フィルターを含む全てを更新
    function updateAllWithFilters() {
      resetPagination();
      populateRankFilters();
      updateAllStats();
    }
    
    // 勝率を計算
    function calculateWinrate(matches, perspective) {
      const totalWithDraws = matches.length; // 引き分けを含む総試合数
      const filtered = matches.filter(m => m.result !== 'draw');
      if (filtered.length === 0) return { wins: 0, losses: 0, draws: totalWithDraws, winrate: '0.0', total: 0, totalWithDraws: totalWithDraws };
      
      const wins = filtered.filter(m => {
        if (perspective === 'survivor') {
          return m.result === 'survivor_win';
        } else {
          return m.result === 'hunter_win';
        }
      }).length;
      
      const losses = filtered.length - wins;
      const draws = matches.filter(m => m.result === 'draw').length;
      const winrate = (wins / filtered.length * 100).toFixed(1);
      
      return { wins, losses, draws, winrate, total: filtered.length, totalWithDraws: totalWithDraws };
    }
    
    // 連勝数を計算
    function calculateWinStreak(matches, perspective) {
      if (matches.length === 0) return 0;
      
      // 最新の試合から遡る
      const sorted = [...matches].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      let streak = 0;
      
      for (const match of sorted) {
        if (match.result === 'draw') continue; // 引き分けは無視
        
        const isWin = (perspective === 'survivor' && match.result === 'survivor_win') || 
                      (perspective === 'hunter' && match.result === 'hunter_win');
        
        if (isWin) {
          streak++;
        } else {
          break;
        }
      }
      
      return streak;
    }
    
    // 平均脱出/脱落人数を計算
    function calculateAverageEscapeCount(matches, perspective) {
      if (matches.length === 0) return 0;
      
      const total = matches.reduce((sum, m) => sum + (m.escapeCount || 0), 0);
      return (total / matches.length).toFixed(1);
    }
    
    // 総合勝率を更新（試合入力タブ内）
    function updateOverallStats() {
      const container = document.getElementById('overall-stats-inline');
      let perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '';
        return;
      }
      
      // 直近100試合モードの場合はフィルタリング
      let displayMatches = perspectiveMatches;
      if (overallStatsMode === 'recent100') {
        displayMatches = perspectiveMatches.slice(-100);
      }
      
      const stats = calculateWinrate(displayMatches, currentPerspective);
      const streak = calculateWinStreak(perspectiveMatches, currentPerspective); // 連勝は全期間で計算
      
      // 小数点第二位まで計算
      const filtered = displayMatches.filter(m => m.result !== 'draw');
      const winrateDecimal = filtered.length > 0 ? 
        (stats.wins / filtered.length * 100).toFixed(2) : '0.00';
      
      const isRecent100 = overallStatsMode === 'recent100';
      const buttonText = isRecent100 ? '全期間' : '百戦勝率';
      const statsTitle = isRecent100 ? '百戦勝率' : '総合勝率';
      
      let html = `<div class="stats-card" style="margin-bottom: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <div style="font-size: 14px; font-weight: 600; color: #666;">${statsTitle}</div>
          <button onclick="toggleOverallStatsMode()" style="padding: 6px 12px; background: #3b82f6; color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer; font-weight: 600;">
            ${buttonText}
          </button>
        </div>
        <div class="overall-stats-display">
          <div class="winrate-big">${winrateDecimal}%</div>
          <div class="record-text">${stats.wins}勝 ${stats.losses}敗 ${stats.draws}分け (${stats.totalWithDraws}試合)</div>`;
      
      if (streak >= 2) {
        html += `<div class="streak-badge"><span class="streak-icon">🔥</span>${streak}連勝中！</div>`;
      }
      
      html += `</div></div>`;
      container.innerHTML = html;
    }
    
    // 総合勝率の表示モードを切り替え
    function toggleOverallStatsMode() {
      overallStatsMode = overallStatsMode === 'all' ? 'recent100' : 'all';
      updateOverallStats();
    }
    
    // ページネーションのHTMLを生成
    function generatePagination(currentPage, totalPages, onPageChange) {
      if (totalPages <= 1) return '';
      
      let html = '<div style="display: flex; flex-direction: column; gap: 10px; align-items: center; margin-top: 20px; padding: 15px;">';
      
      // 前へ/次へボタン + ページ情報
      html += '<div style="display: flex; gap: 10px; align-items: center;">';
      
      // 前へボタン
      if (currentPage > 1) {
        html += `<button onclick="${onPageChange}(${currentPage - 1})" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">← 前へ</button>`;
      } else {
        html += `<button disabled style="padding: 8px 16px; background: #d1d5db; color: #9ca3af; border: none; border-radius: 6px; font-size: 14px; font-weight: 600;">← 前へ</button>`;
      }
      
      // ページ情報
      html += `<span style="font-size: 14px; color: #666; font-weight: 600;">ページ ${currentPage} / ${totalPages}</span>`;
      
      // 次へボタン
      if (currentPage < totalPages) {
        html += `<button onclick="${onPageChange}(${currentPage + 1})" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">次へ →</button>`;
      } else {
        html += `<button disabled style="padding: 8px 16px; background: #d1d5db; color: #9ca3af; border: none; border-radius: 6px; font-size: 14px; font-weight: 600;">次へ →</button>`;
      }
      
      html += '</div>';
      
      // ページ番号ボタン
      html += '<div style="display: flex; gap: 5px; flex-wrap: wrap; justify-content: center;">';
      
      const maxButtons = 7; // 表示する最大ボタン数
      let startPage = Math.max(1, currentPage - Math.floor(maxButtons / 2));
      let endPage = Math.min(totalPages, startPage + maxButtons - 1);
      
      if (endPage - startPage < maxButtons - 1) {
        startPage = Math.max(1, endPage - maxButtons + 1);
      }
      
      // 最初のページ
      if (startPage > 1) {
        html += `<button onclick="${onPageChange}(1)" style="padding: 6px 12px; background: white; color: #3b82f6; border: 1px solid #3b82f6; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600;">1</button>`;
        if (startPage > 2) {
          html += `<span style="padding: 6px; color: #999;">...</span>`;
        }
      }
      
      // ページ番号ボタン
      for (let i = startPage; i <= endPage; i++) {
        if (i === currentPage) {
          html += `<button style="padding: 6px 12px; background: #3b82f6; color: white; border: 1px solid #3b82f6; border-radius: 4px; font-size: 13px; font-weight: 600;">${i}</button>`;
        } else {
          html += `<button onclick="${onPageChange}(${i})" style="padding: 6px 12px; background: white; color: #3b82f6; border: 1px solid #3b82f6; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600;">${i}</button>`;
        }
      }
      
      // 最後のページ
      if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
          html += `<span style="padding: 6px; color: #999;">...</span>`;
        }
        html += `<button onclick="${onPageChange}(${totalPages})" style="padding: 6px 12px; background: white; color: #3b82f6; border: 1px solid #3b82f6; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600;">${totalPages}</button>`;
      }
      
      html += '</div>';
      html += '</div>';
      
      return html;
    }
    
    // ページ変更関数
    function changeTeammatePage(page) {
      currentPages.teammateStats = page;
      updateOpponentStats();
    }
    
    function changeOpponentPage(page) {
      currentPages.opponentStats = page;
      updateOpponentStats();
    }
    
    function changeHistoryPage(page) {
      currentPages.matchHistory = page;
      updateMatchHistory();
    }
    
    // 苦手要素を検出する汎用関数
    function detectWeaknesses(statsData, minMatches = 5) {
      const threshold = currentPerspective === 'hunter' ? 50 : 38;
      const results = [];
      
      Object.keys(statsData).forEach(key => {
        const matches = statsData[key];
        if (matches.length < minMatches) return; // 最小試合数未満は除外
        
        const stats = calculateWinrate(matches, currentPerspective);
        const winrate = parseFloat(stats.winrate);
        
        results.push({
          name: key,
          winrate: winrate,
          stats: stats
        });
      });
      
      // 勝率が低い順にソート
      results.sort((a, b) => a.winrate - b.winrate);
      
      // 基準以下のものを抽出
      const belowThreshold = results.filter(r => r.winrate <= threshold);
      
      if (belowThreshold.length > 0) {
        // 基準以下のものがあれば上位5つまで
        return belowThreshold.slice(0, 5);
      } else if (results.length > 0) {
        // 基準以下がなければ最も低いもの1つ
        return [results[0]];
      } else {
        // データなし
        return [];
      }
    }
    
    // 苦手要素のHTMLを生成
    function generateWeaknessHTML(weaknesses, title) {
      if (weaknesses.length === 0) return '';
      
      let html = `<div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 12px 15px; margin: 15px 0; border-radius: 6px;">
        <div style="font-size: 13px; font-weight: 600; color: #92400e; margin-bottom: 8px;">${title}</div>
        <div style="font-size: 12px; color: #78350f;">`;
      
      weaknesses.forEach((item, index) => {
        html += `${index + 1}. ${item.name} <span style="font-weight: 600;">${item.stats.winrate}%</span> <span style="color: #a16207;">(${item.stats.wins}勝${item.stats.losses}敗${item.stats.draws}分)</span>`;
        if (index < weaknesses.length - 1) html += '<br>';
      });
      
      html += `</div></div>`;
      return html;
    }
    
    // 苦手要素を検出
    function detectWeaknesses(data, minMatches = 5) {
      const threshold = currentPerspective === 'hunter' ? 50 : 38;
      const weaknesses = [];
      
      Object.keys(data).forEach(key => {
        const matches = data[key];
        if (matches.length >= minMatches) {
          const stats = calculateWinrate(matches, currentPerspective);
          const winrate = parseFloat(stats.winrate) || 0;
          
          weaknesses.push({
            name: key,
            winrate: winrate,
            stats: stats
          });
        }
      });
      
      // 閾値以下のものをフィルター
      let filtered = weaknesses.filter(w => w.winrate <= threshold);
      
      // 該当なしの場合は最も低いものを返す
      if (filtered.length === 0 && weaknesses.length > 0) {
        weaknesses.sort((a, b) => a.winrate - b.winrate);
        filtered = [weaknesses[0]];
      } else {
        // 勝率が低い順にソート
        filtered.sort((a, b) => a.winrate - b.winrate);
      }
      
      return filtered.slice(0, 5); // 上位5つ
    }
    
    // 苦手要素を検出
    function detectWeaknesses(stats, minGames = 5) {
      const threshold = currentPerspective === 'hunter' ? 50 : 38;
      
      // ステップ1：有効なデータを抽出（5試合以上）
      const validData = [];
      Object.keys(stats).forEach(key => {
        const matches = stats[key];
        if (matches.length >= minGames) {
          const result = calculateWinrate(matches, currentPerspective);
          const winrate = parseFloat(result.winrate);
          
          validData.push({
            name: key,
            winrate: winrate,
            wins: result.wins,
            losses: result.losses,
            draws: result.draws,
            total: result.totalWithDraws,
            stats: result
          });
        }
      });
      
      // ステップ2：有効データが3つ未満なら空配列を返す（表示しない）
      if (validData.length < 3) {
        return [];
      }
      
      // ステップ3：閾値以下のデータを抽出
      const belowThreshold = validData.filter(d => d.winrate <= threshold);
      
      // ステップ4：閾値以下のデータがある場合
      if (belowThreshold.length > 0) {
        // 勝率が低い順にソートして最大5つ返す
        return belowThreshold.sort((a, b) => a.winrate - b.winrate).slice(0, 5);
      }
      
      // ステップ5：閾値以下がない場合、最も低いもの1つだけ返す（ただし100%は除外）
      const sortedData = validData.sort((a, b) => a.winrate - b.winrate);
      
      // 最も低いものが100%の場合は表示しない
      if (sortedData.length > 0 && sortedData[0].winrate === 100) {
        return [];
      }
      
      return sortedData.slice(0, 1);
    }
    
    // 苦手要素表示HTMLを生成（控えめなデザイン）
    function generateWeaknessHTML(weaknesses, title, icon) {
      if (weaknesses.length === 0) return '';
      
      const threshold = currentPerspective === 'hunter' ? 50 : 38;
      const hasWeakness = weaknesses.some(w => w.winrate <= threshold);
      const displayTitle = `苦手${title}`;
      
      let html = `
        <div style="background: #f8f9fa; border-left: 3px solid #6c757d; padding: 12px 15px; margin-bottom: 15px; border-radius: 4px;">
          <div style="font-weight: 600; font-size: 13px; color: #495057; margin-bottom: 8px;">${displayTitle}</div>
          <div style="display: flex; flex-direction: column; gap: 6px;">
      `;
      
      weaknesses.forEach((item, index) => {
        const textColor = item.winrate <= threshold ? '#dc3545' : '#6c757d';
        html += `
          <div style="display: flex; justify-content: space-between; align-items: center; font-size: 13px;">
            <div>
              <span style="color: #212529;">${index + 1}. ${item.name}</span>
              <span style="font-size: 11px; color: #6c757d; margin-left: 6px;">(${item.total}試合)</span>
            </div>
            <div style="font-weight: 600; color: ${textColor};">${item.winrate.toFixed(1)}%</div>
          </div>
        `;
      });
      
      html += `</div></div>`;
      return html;
    }
    
    // 自キャラ別勝率を更新
    function updateCharacterStats() {
      const container = document.getElementById('character-stats');
      const rankFilter = document.getElementById('character-rank-filter').value;
      const perspectiveMatches = getFilteredMatches(rankFilter);
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        return;
      }
      
      const characterStats = {};
      
      perspectiveMatches.forEach(match => {
        const char = match.myCharacter;
        if (!characterStats[char]) {
          characterStats[char] = [];
        }
        characterStats[char].push(match);
      });
      
      // 苦手キャラクターを検出
      const weakCharacters = detectWeaknesses(characterStats);
      
      const sortedChars = Object.keys(characterStats).sort((a, b) => {
        const statsA = calculateWinrate(characterStats[a], currentPerspective);
        const statsB = calculateWinrate(characterStats[b], currentPerspective);
        
        // 勝率で比較
        const winrateA = parseFloat(statsA.winrate);
        const winrateB = parseFloat(statsB.winrate);
        const winrateDiff = winrateB - winrateA;
        if (winrateDiff !== 0) return winrateDiff;
        
        // 勝率が同じなら平均脱出/脱落人数で比較
        const avgEscapeA = parseFloat(calculateAverageEscapeCount(characterStats[a], currentPerspective));
        const avgEscapeB = parseFloat(calculateAverageEscapeCount(characterStats[b], currentPerspective));
        
        if (currentPerspective === 'survivor') {
          // サバイバー: 平均脱出人数が多い順
          const avgDiff = avgEscapeB - avgEscapeA;
          if (Math.abs(avgDiff) > 0.01) return avgDiff;
        } else {
          // ハンター: 平均脱落人数が多い順（脱落 = 4 - 脱出）
          const avgFallA = 4 - avgEscapeA;
          const avgFallB = 4 - avgEscapeB;
          const avgDiff = avgFallB - avgFallA;
          if (Math.abs(avgDiff) > 0.01) return avgDiff;
        }
        
        // それでも同じなら試合数で比較（引き分け含む）
        return statsB.totalWithDraws - statsA.totalWithDraws;
      });
      
      let html = '';
      
      // 苦手キャラクターを表示
      html += generateWeaknessHTML(weakCharacters, 'キャラクター', '👤');
      
      html += `<div class="stats-card">
        <div class="stats-title">キャラクター別勝率（${currentPerspective === 'survivor' ? 'サバイバー' : 'ハンター'}）</div>
        <div class="bar-chart-horizontal">`;
      
      sortedChars.forEach(char => {
        const stats = calculateWinrate(characterStats[char], currentPerspective);
        const avgEscape = calculateAverageEscapeCount(characterStats[char], currentPerspective);
        const winrateNum = parseFloat(stats.winrate) || 0;
        const barWidth = winrateNum;
        
        const avgText = currentPerspective === 'survivor' 
          ? `平均脱出${avgEscape}人` 
          : `平均脱落${(4 - parseFloat(avgEscape)).toFixed(1)}人`;
        
        const isZero = winrateNum === 0;
        
        html += `
          <div class="bar-row">
            <div class="bar-label-wrapper">
              <div class="bar-label">${char}</div>
              <div class="bar-sublabel">${avgText}<br>${stats.totalWithDraws}試合</div>
            </div>
            <div class="bar-wrapper">
              ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
              <div class="bar-visual" style="width: ${barWidth}%;">
                <div class="bar-value">${stats.winrate}%</div>
              </div>`}
            </div>
          </div>
        `;
      });
      
      html += '</div></div>';
      container.innerHTML = html;
    }
    
    // マップ別勝率を更新
    function updateMapStats() {
      const container = document.getElementById('map-stats');
      const rankFilter = document.getElementById('map-rank-filter').value;
      const charFilter = document.getElementById('map-char-filter').value;
      let perspectiveMatches = getFilteredMatches(rankFilter);
      
      // 自キャラでフィルター
      if (charFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => m.myCharacter === charFilter);
      }
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        return;
      }
      
      const mapStats = {};
      
      perspectiveMatches.forEach(match => {
        const map = match.map;
        if (!mapStats[map]) {
          mapStats[map] = [];
        }
        mapStats[map].push(match);
      });
      
      // 苦手マップを検出
      const weakMaps = detectWeaknesses(mapStats);
      
      const sortedMaps = Object.keys(mapStats).sort((a, b) => {
        const statsA = calculateWinrate(mapStats[a], currentPerspective);
        const statsB = calculateWinrate(mapStats[b], currentPerspective);
        
        // 勝率で比較
        const winrateDiff = parseFloat(statsB.winrate) - parseFloat(statsA.winrate);
        if (winrateDiff !== 0) return winrateDiff;
        
        // 勝率が同じなら試合数で比較（引き分け含む）
        return statsB.totalWithDraws - statsA.totalWithDraws;
      });
      
      let html = '';
      
      // 苦手マップを表示
      html += generateWeaknessHTML(weakMaps, 'マップ', '🗺️');
      
      html += `<div class="stats-card">
        <div class="stats-title">マップ別勝率</div>
        <div class="bar-chart-horizontal">`;
      
      sortedMaps.forEach(map => {
        const stats = calculateWinrate(mapStats[map], currentPerspective);
        const winrateNum = parseFloat(stats.winrate) || 0;
        const barWidth = winrateNum;
        const isZero = winrateNum === 0;
        
        html += `
          <div class="bar-row">
            <div class="bar-label-wrapper">
              <div class="bar-label">${map}</div>
              <div class="bar-sublabel">${stats.wins}勝${stats.losses}敗${stats.draws}分</div>
            </div>
            <div class="bar-wrapper">
              ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
              <div class="bar-visual" style="width: ${barWidth}%;">
                <div class="bar-value">${stats.winrate}%</div>
              </div>`}
            </div>
          </div>
        `;
      });
      
      html += '</div></div>';
      container.innerHTML = html;
    }
    
    // 対戦相手別勝率を更新
    function updateOpponentStats() {
      const container = document.getElementById('opponent-stats');
      const rankFilter = document.getElementById('opponent-rank-filter').value;
      const myCharFilter = document.getElementById('my-char-filter').value;
      const opponentHunterFilter = document.getElementById('opponent-hunter-filter') ? document.getElementById('opponent-hunter-filter').value : 'all';
      const mapFilter = document.getElementById('opponent-map-filter').value;
      let perspectiveMatches = getFilteredMatches(rankFilter);
      
      // 自キャラでフィルター
      if (myCharFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => m.myCharacter === myCharFilter);
      }
      
      // 対戦相手ハンターでフィルター（サバイバー視点のみ）
      if (currentPerspective === 'survivor' && opponentHunterFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => m.opponentHunter === opponentHunterFilter);
      }
      
      // マップでフィルター
      if (mapFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => m.map === mapFilter);
      }
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        return;
      }
      
      if (currentPerspective === 'survivor') {
        const hunterStats = {};
        const teammateStats = {};
        
        perspectiveMatches.forEach(match => {
          const hunter = match.opponentHunter;
          if (!hunterStats[hunter]) {
            hunterStats[hunter] = [];
          }
          hunterStats[hunter].push(match);
          
          match.teammates.forEach(teammate => {
            if (!teammateStats[teammate]) {
              teammateStats[teammate] = [];
            }
            teammateStats[teammate].push(match);
          });
        });
        
        // 苦手要素を検出
        const weakHunters = detectWeaknesses(hunterStats);
        const weakTeammates = detectWeaknesses(teammateStats);
        
        let html = '';
        
        // 苦手ハンターを表示
        html += generateWeaknessHTML(weakHunters, '対戦相手（ハンター）', '👻');
        
        // 苦手味方を表示
        html += generateWeaknessHTML(weakTeammates, '味方キャラクター', '👥');
        
        // 対戦相手ハンター別勝率
        html += `<div class="stats-card">
          <div class="stats-title">対戦相手ハンター別勝率</div>
          <div class="bar-chart-horizontal">`;
        
        const sortedHunters = Object.keys(hunterStats).sort((a, b) => {
          const statsA = calculateWinrate(hunterStats[a], currentPerspective);
          const statsB = calculateWinrate(hunterStats[b], currentPerspective);
          
          const winrateDiff = parseFloat(statsB.winrate) - parseFloat(statsA.winrate);
          if (winrateDiff !== 0) return winrateDiff;
          
          return statsB.totalWithDraws - statsA.totalWithDraws;
        });
        
        const totalHunters = sortedHunters.length;
        const totalHunterPages = Math.ceil(totalHunters / itemsPerPage);
        const hunterStartIndex = (currentPages.opponentStats - 1) * itemsPerPage;
        const hunterEndIndex = Math.min(hunterStartIndex + itemsPerPage, totalHunters);
        
        sortedHunters.slice(hunterStartIndex, hunterEndIndex).forEach(hunter => {
          const stats = calculateWinrate(hunterStats[hunter], currentPerspective);
          const winrateNum = parseFloat(stats.winrate) || 0;
          const barWidth = winrateNum;
          const isZero = winrateNum === 0;
          
          html += `
            <div class="bar-row">
              <div class="bar-label-wrapper">
                <div class="bar-label">${hunter}</div>
                <div class="bar-sublabel">${stats.wins}勝${stats.losses}敗${stats.draws}分</div>
              </div>
              <div class="bar-wrapper">
                ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
                <div class="bar-visual" style="width: ${barWidth}%;">
                  <div class="bar-value">${stats.winrate}%</div>
                </div>`}
              </div>
            </div>
          `;
        });
        
        html += '</div>';
        html += generatePagination(currentPages.opponentStats, totalHunterPages, 'changeOpponentPage');
        html += '</div>';
        
        // 味方編成別勝率
        html += `<div class="stats-card">
          <div class="stats-title">味方編成別勝率</div>
          <div class="bar-chart-horizontal">`;
        
        const sortedTeammates = Object.keys(teammateStats).sort((a, b) => {
          const statsA = calculateWinrate(teammateStats[a], currentPerspective);
          const statsB = calculateWinrate(teammateStats[b], currentPerspective);
          
          const winrateDiff = parseFloat(statsB.winrate) - parseFloat(statsA.winrate);
          if (winrateDiff !== 0) return winrateDiff;
          
          return statsB.totalWithDraws - statsA.totalWithDraws;
        });
        
        const totalTeammates = sortedTeammates.length;
        const totalTeammatePages = Math.ceil(totalTeammates / itemsPerPage);
        const teammateStartIndex = (currentPages.teammateStats - 1) * itemsPerPage;
        const teammateEndIndex = Math.min(teammateStartIndex + itemsPerPage, totalTeammates);
        
        sortedTeammates.slice(teammateStartIndex, teammateEndIndex).forEach(teammate => {
          const stats = calculateWinrate(teammateStats[teammate], currentPerspective);
          const winrateNum = parseFloat(stats.winrate) || 0;
          const barWidth = winrateNum;
          const isZero = winrateNum === 0;
          
          html += `
            <div class="bar-row">
              <div class="bar-label-wrapper">
                <div class="bar-label">${teammate}</div>
                <div class="bar-sublabel">${stats.wins}勝${stats.losses}敗${stats.draws}分</div>
              </div>
              <div class="bar-wrapper">
                ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
                <div class="bar-visual" style="width: ${barWidth}%;">
                  <div class="bar-value">${stats.winrate}%</div>
                </div>`}
              </div>
            </div>
          `;
        });
        
        html += '</div>';
        html += generatePagination(currentPages.teammateStats, totalTeammatePages, 'changeTeammatePage');
        html += '</div>';
        container.innerHTML = html;
        
      } else {
        const survivorStats = {};
        
        perspectiveMatches.forEach(match => {
          match.opponentSurvivors.forEach(survivor => {
            if (!survivorStats[survivor]) {
              survivorStats[survivor] = [];
            }
            survivorStats[survivor].push(match);
          });
        });
        
        // 苦手サバイバーを検出
        const weakSurvivors = detectWeaknesses(survivorStats);
        
        let html = '';
        
        // 苦手サバイバーを表示
        html += generateWeaknessHTML(weakSurvivors, '対戦相手（サバイバー）', '👤');
        
        html += `<div class="stats-card">
          <div class="stats-title">対戦相手サバイバー別勝率</div>
          <div class="bar-chart-horizontal">`;
        
        const sortedSurvivors = Object.keys(survivorStats).sort((a, b) => {
          const statsA = calculateWinrate(survivorStats[a], currentPerspective);
          const statsB = calculateWinrate(survivorStats[b], currentPerspective);
          
          const winrateDiff = parseFloat(statsB.winrate) - parseFloat(statsA.winrate);
          if (winrateDiff !== 0) return winrateDiff;
          
          return statsB.totalWithDraws - statsA.totalWithDraws;
        });
        
        const totalSurvivors = sortedSurvivors.length;
        const totalPages = Math.ceil(totalSurvivors / itemsPerPage);
        const startIndex = (currentPages.opponentStats - 1) * itemsPerPage;
        const endIndex = Math.min(startIndex + itemsPerPage, totalSurvivors);
        
        sortedSurvivors.slice(startIndex, endIndex).forEach(survivor => {
          const stats = calculateWinrate(survivorStats[survivor], currentPerspective);
          const winrateNum = parseFloat(stats.winrate) || 0;
          const barWidth = winrateNum;
          const isZero = winrateNum === 0;
          
          html += `
            <div class="bar-row">
              <div class="bar-label-wrapper">
                <div class="bar-label">${survivor}</div>
                <div class="bar-sublabel">${stats.wins}勝${stats.losses}敗${stats.draws}分</div>
              </div>
              <div class="bar-wrapper">
                ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
                <div class="bar-visual" style="width: ${barWidth}%;">
                  <div class="bar-value">${stats.winrate}%</div>
                </div>`}
              </div>
            </div>
          `;
        });
        
        html += '</div>';
        html += generatePagination(currentPages.opponentStats, totalPages, 'changeOpponentPage');
        html += '</div>';
        container.innerHTML = html;
      }
    }
    
    // 試合履歴を更新
    function updateMatchHistory() {
      const container = document.getElementById('match-history');
      const rankFilter = document.getElementById('history-rank-filter').value;
      const perspectiveMatches = getFilteredMatches(rankFilter).reverse();
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        return;
      }
      
      const totalMatches = perspectiveMatches.length;
      const totalPages = Math.ceil(totalMatches / itemsPerPage);
      const startIndex = (currentPages.matchHistory - 1) * itemsPerPage;
      const endIndex = Math.min(startIndex + itemsPerPage, totalMatches);
      
      let html = '<div class="match-history">';
      
      perspectiveMatches.slice(startIndex, endIndex).forEach(match => {
        const resultText = match.result === 'survivor_win' ? 'サバイバー勝利' : match.result === 'hunter_win' ? 'ハンター勝利' : '引き分け';
        const isWin = (currentPerspective === 'survivor' && match.result === 'survivor_win') || 
                      (currentPerspective === 'hunter' && match.result === 'hunter_win');
        const displayResultClass = isWin ? 'win' : match.result === 'draw' ? 'draw' : 'lose';
        const escapeInfo = match.escapeCount !== undefined ? ` (脱出${match.escapeCount}人)` : '';
        const rankInfo = match.rank ? `[${match.rank}] ` : '';
        
        let details = '';
        if (match.perspective === 'survivor') {
          details = `${rankInfo}${match.myCharacter} + ${match.teammates.join(', ')} vs ${match.opponentHunter} @ ${match.map}${escapeInfo}`;
        } else {
          details = `${rankInfo}${match.myCharacter} vs ${match.opponentSurvivors.join(', ')} @ ${match.map}${escapeInfo}`;
        }
        
        html += `
          <div class="match-item">
            <div class="match-info">
              <span class="match-result ${displayResultClass}">${resultText}</span>
              <span>${details}</span>
            </div>
            <div class="match-actions">
              <button type="button" class="edit-button" onclick="event.stopPropagation(); editMatch(${match.id}); return false;">編集</button>
              <button type="button" class="delete-button" onclick="event.stopPropagation(); deleteMatch(${match.id}); return false;">削除</button>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      html += generatePagination(currentPages.matchHistory, totalPages, 'changeHistoryPage');
      container.innerHTML = html;
    }
    
    // 試合を編集
    function editMatch(id) {
      console.log('editMatch called with id:', id);
      
      const match = matches.find(m => m.id === id);
      if (!match) {
        console.error('Match not found:', id);
        return;
      }
      
      console.log('Match found:', match);
      editingMatchId = id;
      
      if (match.perspective === 'survivor') {
        currentPerspective = 'survivor';
        document.getElementById('survivor-rank').value = match.rank || '';
        document.getElementById('my-survivor').value = match.myCharacter;
        document.getElementById('teammate-1').value = match.teammates[0];
        document.getElementById('teammate-2').value = match.teammates[1];
        document.getElementById('teammate-3').value = match.teammates[2];
        document.getElementById('opponent-hunter').value = match.opponentHunter;
        document.getElementById('survivor-map').value = match.map;
        selectedEscapeCount.survivor = match.escapeCount !== undefined ? match.escapeCount : null;
        
        document.querySelectorAll('.perspective-tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.perspective-tab')[0].classList.add('active');
        document.getElementById('survivor-input').style.display = 'block';
        document.getElementById('hunter-input').style.display = 'none';
        
        updateSurvivorSelects(); // 選択肢を更新
        
        document.querySelectorAll('#survivor-input .result-button').forEach((btn, index) => {
          btn.classList.remove('selected');
          if (match.escapeCount !== undefined && index === match.escapeCount) {
            btn.classList.add('selected');
          }
        });
        
        // 選択肢を更新
        updateSurvivorSelectOptions();
      } else {
        currentPerspective = 'hunter';
        document.getElementById('hunter-rank').value = match.rank || '';
        document.getElementById('my-hunter').value = match.myCharacter;
        document.getElementById('opponent-survivor-1').value = match.opponentSurvivors[0];
        document.getElementById('opponent-survivor-2').value = match.opponentSurvivors[1];
        document.getElementById('opponent-survivor-3').value = match.opponentSurvivors[2];
        document.getElementById('opponent-survivor-4').value = match.opponentSurvivors[3];
        document.getElementById('hunter-map').value = match.map;
        selectedEscapeCount.hunter = match.escapeCount !== undefined ? match.escapeCount : null;
        
        document.querySelectorAll('.perspective-tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.perspective-tab')[1].classList.add('active');
        document.getElementById('survivor-input').style.display = 'none';
        document.getElementById('hunter-input').style.display = 'block';
        
        updateHunterOpponentSelectOptions(); // 選択肢を更新
        
        document.querySelectorAll('#hunter-input .result-button').forEach((btn, index) => {
          btn.classList.remove('selected');
          if (match.escapeCount !== undefined && index === match.escapeCount) {
            btn.classList.add('selected');
          }
        });
      }
      
      document.querySelectorAll('.main-tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.main-tab')[0].classList.add('active');
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      document.getElementById('input-tab').classList.add('active');
      
      window.scrollTo(0, 0);
    }
    
    // 試合を削除（確認なし）
    function deleteMatch(id) {
      console.log('deleteMatch called with id:', id);
      
      matches = matches.filter(m => m.id !== id);
      saveData();
      updateAllWithFilters();
      
      console.log('Match deleted successfully');
    }
    
    // 全データをリセット（確認ダイアログあり）
    function resetAllData() {
      console.log('resetAllData called');
      
      // 第一確認
      const firstConfirm = confirm('本当に全てのデータをリセットしますか？\nこの操作は取り消せません。');
      if (!firstConfirm) {
        console.log('User cancelled at first confirmation');
        return;
      }
      
      // 第二確認（念押し）
      const secondConfirm = confirm('最終確認：全データを削除します。\n本当によろしいですか？');
      if (!secondConfirm) {
        console.log('User cancelled at second confirmation');
        return;
      }
      
      matches = [];
      saveData();
      updateAllWithFilters();
      
      console.log('All data reset successfully');
    }
    
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
